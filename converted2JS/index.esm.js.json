{"version":3,"file":"index.esm.js","sources":["../src/Trigger.js","../src/renderer/Matrix.js","../src/renderer/Skin.js","../src/renderer/Shaders.js","../src/renderer/effectInfo.js","../src/renderer/ShaderManager.js","../src/renderer/PenSkin.js","../src/renderer/Rectangle.js","../src/renderer/BitmapSkin.js","../src/renderer/SpeechBubbleSkin.js","../src/renderer/VectorSkin.js","../src/Costume.js","../src/renderer/SkinCache.js","../src/Color.js","../src/lib/decode-adpcm-audio.js","../src/Sound.js","../src/Sprite.js","../src/Renderer.js","../src/Input.js","../src/Project.js","../src/Watcher.js"],"sourcesContent":["const GREEN_FLAG = Symbol(\"GREEN_FLAG\");\nconst KEY_PRESSED = Symbol(\"KEY_PRESSED\");\nconst BROADCAST = Symbol(\"BROADCAST\");\nconst CLICKED = Symbol(\"CLICKED\");\nconst CLONE_START = Symbol(\"CLONE_START\");\n\nexport default class Trigger {\n  constructor(trigger, options, script) {\n    this.trigger = trigger;\n\n    if (typeof script === \"undefined\") {\n      this.options = {};\n      this._script = options;\n    } else {\n      this.options = options;\n      this._script = script;\n    }\n\n    this.done = false;\n    this.stop = () => {};\n  }\n\n  matches(trigger, options) {\n    if (this.trigger !== trigger) return false;\n    for (let option in options) {\n      if (this.options[option] !== options[option]) return false;\n    }\n\n    return true;\n  }\n\n  start(target) {\n    this.stop();\n\n    const boundScript = this._script.bind(target);\n\n    this.done = false;\n    this._runningScript = boundScript();\n\n    return new Promise(resolve => {\n      this.stop = () => {\n        this.done = true;\n        resolve();\n      };\n    });\n  }\n\n  step() {\n    this.done = this._runningScript.next().done;\n    if (this.done) this.stop();\n  }\n\n  static get GREEN_FLAG() {\n    return GREEN_FLAG;\n  }\n  static get KEY_PRESSED() {\n    return KEY_PRESSED;\n  }\n  static get BROADCAST() {\n    return BROADCAST;\n  }\n  static get CLICKED() {\n    return CLICKED;\n  }\n  static get CLONE_START() {\n    return CLONE_START;\n  }\n}\n","/* Adapted from gl-matrix\n * https://github.com/toji/gl-matrix\n */\n\n// 3x3 transform matrix operations, unrolled 4 da speedz.\nexport default class Matrix {\n  // Create a new 3x3 transform matrix, initialized to the identity matrix.\n  static create() {\n    const matrix = new Float32Array(9);\n    matrix[0] = 1;\n    matrix[4] = 1;\n    matrix[8] = 1;\n    return matrix;\n  }\n\n  // Translate a matrix by the given X and Y values\n  static translate(dst, src, x, y) {\n    const a00 = src[0],\n      a01 = src[1],\n      a02 = src[2],\n      a10 = src[3],\n      a11 = src[4],\n      a12 = src[5],\n      a20 = src[6],\n      a21 = src[7],\n      a22 = src[8];\n\n    dst[0] = a00;\n    dst[1] = a01;\n    dst[2] = a02;\n\n    dst[3] = a10;\n    dst[4] = a11;\n    dst[5] = a12;\n\n    dst[6] = x * a00 + y * a10 + a20;\n    dst[7] = x * a01 + y * a11 + a21;\n    dst[8] = x * a02 + y * a12 + a22;\n    return dst;\n  }\n\n  // Rotate a matrix, in radians\n  static rotate(dst, src, rad) {\n    const a00 = src[0],\n      a01 = src[1],\n      a02 = src[2],\n      a10 = src[3],\n      a11 = src[4],\n      a12 = src[5],\n      a20 = src[6],\n      a21 = src[7],\n      a22 = src[8],\n      s = Math.sin(rad),\n      c = Math.cos(rad);\n\n    dst[0] = c * a00 + s * a10;\n    dst[1] = c * a01 + s * a11;\n    dst[2] = c * a02 + s * a12;\n\n    dst[3] = c * a10 - s * a00;\n    dst[4] = c * a11 - s * a01;\n    dst[5] = c * a12 - s * a02;\n\n    dst[6] = a20;\n    dst[7] = a21;\n    dst[8] = a22;\n    return dst;\n  }\n\n  // Scale a matrix by the given X and Y values\n  static scale(dst, src, x, y) {\n    dst[0] = x * src[0];\n    dst[1] = x * src[1];\n    dst[2] = x * src[2];\n\n    dst[3] = y * src[3];\n    dst[4] = y * src[4];\n    dst[5] = y * src[5];\n\n    dst[6] = src[6];\n    dst[7] = src[7];\n    dst[8] = src[8];\n    return dst;\n  }\n}\n","export default class Skin {\n  constructor(renderer) {\n    this.renderer = renderer;\n    this.gl = renderer.gl;\n    this.used = true;\n  }\n\n  // Get the skin's texture for a given (screen-space) scale.\n  /* eslint-disable-next-line no-unused-vars */\n  getTexture(scale) {\n    return null;\n  }\n\n  // Helper function to create a texture from an image and handle all the boilerplate.\n  _makeTexture(image, filtering) {\n    const gl = this.gl;\n    const glTexture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, glTexture);\n    // These need to be set because most sprite textures don't have power-of-two dimensions.\n    // Non-power-of-two textures only work with gl.CLAMP_TO_EDGE wrapping behavior,\n    // and because they don't support automatic mipmaps, can only use non-mipmap texture filtering.\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filtering);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filtering);\n    if (image)\n      gl.texImage2D(\n        gl.TEXTURE_2D,\n        0,\n        gl.RGBA,\n        gl.RGBA,\n        gl.UNSIGNED_BYTE,\n        image\n      );\n\n    return glTexture;\n  }\n\n  // Helper function to set this skin's size based on an image that may or may not be loaded.\n  _setSizeFromImage(image) {\n    if (image.complete) {\n      this.width = image.naturalWidth;\n      this.height = image.naturalHeight;\n    } else {\n      image.addEventListener(\"load\", () => {\n        this.width = image.naturalWidth;\n        this.height = image.naturalHeight;\n      });\n    }\n  }\n\n  // Clean up any textures or other objets created by this skin.\n  destroy() {}\n}\n","const SpriteShader = {};\n\nSpriteShader.vertex = `\nprecision mediump float;\n\nattribute vec2 a_position;\nuniform mat3 u_transform;\nuniform vec2 u_stageSize;\n\nvarying vec2 v_texCoord;\n\nvoid main() {\n  v_texCoord = vec2(a_position.x, 1.0 - a_position.y);\n  gl_Position = vec4((u_transform * vec3(a_position, 1.0)) / vec3(u_stageSize * 0.5, 1.0), 1.0);\n}\n`;\n\nSpriteShader.fragment = `\nprecision mediump float;\n\nconst float epsilon = 1e-3;\n\nuniform sampler2D u_texture;\nvarying vec2 v_texCoord;\n\n#ifdef EFFECT_color\nuniform float u_color;\n#endif\n\n#ifdef EFFECT_fisheye\nuniform float u_fisheye;\n#endif\n\n#ifdef EFFECT_whirl\nuniform float u_whirl;\n#endif\n\n#ifdef EFFECT_pixelate\nuniform float u_pixelate;\nuniform vec2 u_skinSize;\n#endif\n\n#ifdef EFFECT_mosaic\nuniform float u_mosaic;\n#endif\n\n#ifdef EFFECT_brightness\nuniform float u_brightness;\n#endif\n\n#ifdef EFFECT_ghost\nuniform float u_ghost;\n#endif\n\n#if defined(EFFECT_whirl) || defined(EFFECT_fisheye) || defined(EFFECT_pixelate)\nconst vec2 CENTER = vec2(0.5, 0.5);\n#endif\n\n#ifdef DRAW_MODE_COLOR_MASK\nuniform vec4 u_colorMask;\n\n// TODO: Scratch 2.0 and Scratch 3.0's CPU path check if the top 6 bits match,\n// which a tolerance of 3/255 should be equivalent to,\n// but Scratch's GPU path has a tolerance of 2/255.\nconst vec3 COLOR_MASK_TOLERANCE = vec3(3.0 / 255.0);\n#endif\n\n#ifdef EFFECT_color\n// Taken from http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 rgb2hsv(vec3 c)\n{\n  vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n  vec4 p = c.g < c.b ? vec4(c.bg, K.wz) : vec4(c.gb, K.xy);\n  vec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);\n\n  float d = q.x - min(q.w, q.y);\n  float e = 1.0e-10;\n  return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n#endif\n\nvoid main() {\n  vec2 coord = v_texCoord;\n\n  #ifdef EFFECT_mosaic\n  {\n    float mosaicFactor = clamp(floor(abs(u_mosaic + 10.0) / 10.0 + 0.5), 1.0, 512.0);\n    coord = fract(coord * mosaicFactor);\n  }\n  #endif\n\n  #ifdef EFFECT_pixelate\n    vec2 pixSize = u_skinSize / (abs(u_pixelate) * 0.1);\n    coord = (floor(coord * pixSize) + CENTER) / pixSize;\n  #endif\n\n  #ifdef EFFECT_whirl\n  {\n    const float PI_OVER_180 = 0.017453292519943295;\n    vec2 offset = coord - CENTER;\n    float whirlFactor = max(1.0 - (length(offset) * 2.0), 0.0);\n    float whirl = (-u_whirl * PI_OVER_180) * whirlFactor * whirlFactor;\n    float s = sin(whirl);\n    float c = cos(whirl);\n    mat2 rotationMatrix = mat2(c, -s, s, c);\n    coord = rotationMatrix * offset + CENTER;\n  }\n  #endif\n\n  #ifdef EFFECT_fisheye\n  {\n    vec2 vec = (coord - CENTER) / CENTER;\n    float len = length(vec) + epsilon;\n    float factor = max(0.0, (u_fisheye + 100.0) / 100.0);\n    float r = pow(min(len, 1.0), factor) * max(1.0, len);\n    vec2 unit = vec / len;\n    coord = CENTER + (r * unit * CENTER);\n  }\n  #endif\n\n  vec4 color = texture2D(u_texture, coord);\n\n  #if defined(EFFECT_color) || defined(EFFECT_brightness)\n  // Un-premultiply color values by alpha channel\n  vec3 unmul = color.rgb / color.a;\n\n  #ifdef EFFECT_color\n  {\n    vec3 hsv = rgb2hsv(unmul);\n    const float minLightness = 0.11 / 2.0;\n    const float minSaturation = 0.09;\n\n    hsv.z = max(minLightness, hsv.z);\n    hsv.y = max(minSaturation, hsv.y);\n\n    hsv.x = mod(hsv.x + (u_color / 200.0), 1.0);\n\n    unmul = hsv2rgb(hsv);\n  }\n  #endif\n\n  #ifdef EFFECT_brightness\n  {\n    unmul = clamp(unmul + clamp(u_brightness * 0.01, -1.0, 1.0), 0.0, 1.0);\n  }\n  #endif\n\n  color = vec4(unmul * color.a, color.a);\n\n  #endif // defined(defined(EFFECT_color) || defined(EFFECT_brightness))\n\n  #ifdef DRAW_MODE_COLOR_MASK\n  vec3 diff = abs(u_colorMask.rgb - color.rgb);\n  if (any(greaterThan(diff, COLOR_MASK_TOLERANCE))) {\n    discard;\n  }\n  #endif\n\n  #ifdef EFFECT_ghost\n  color *= (1.0 - clamp(u_ghost * 0.01, 0.0, 1.0));\n  #endif\n\n  #ifdef DRAW_MODE_SILHOUETTE\n  if (color.a == 0.0) {\n    discard;\n  }\n  #endif\n\n  gl_FragColor = color;\n}\n`;\n\nconst PenLineShader = {};\n\nPenLineShader.vertex = `\nprecision mediump float;\n\nattribute vec2 a_position;\nuniform vec4 u_penPoints;\nuniform vec2 u_penSkinSize;\nuniform float u_penSize;\n\nvarying vec2 v_texCoord;\n\nvoid main() {\n  float penRadius = u_penSize * 0.5;\n  vec2 topRight = floor(min(u_penPoints.xy, u_penPoints.zw) - penRadius);\n  vec2 bottomLeft = ceil(max(u_penPoints.xy, u_penPoints.zw) + penRadius);\n  vec2 penBounds = a_position * (bottomLeft - topRight) + topRight;\n\n  vec2 position = (penBounds / u_penSkinSize) * 2.0;\n  v_texCoord = penBounds;\n  gl_Position = vec4(position, 1.0, 1.0);\n}\n`;\n\nPenLineShader.fragment = `\nprecision mediump float;\n\nuniform sampler2D u_texture;\nuniform vec4 u_penPoints;\nuniform vec4 u_penColor;\nuniform float u_penSize;\nvarying vec2 v_texCoord;\n\nvoid main() {\n  // Maaaaagic antialiased-line-with-round-caps shader.\n  // Adapted from Inigo Quilez' 2D distance function cheat sheet\n  // https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n  vec2 pa = v_texCoord - u_penPoints.xy, ba = u_penPoints.zw - u_penPoints.xy;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\n  float cappedLine = clamp((u_penSize + 1.0) * 0.5 - length(pa - ba*h), 0.0, 1.0);\n\n  // Premultiply pen color by its alpha\n  vec4 premul = vec4(vec3(u_penColor.rgb * u_penColor.a), u_penColor.a);\n\n  gl_FragColor = premul * cappedLine;\n}\n`;\n\nexport { SpriteShader, PenLineShader };\n","// This file exists to specify a mapping from numeric indices to effect names in all places that require it.\nconst effectNames = [\n  \"color\",\n  \"fisheye\",\n  \"whirl\",\n  \"pixelate\",\n  \"mosaic\",\n  \"brightness\",\n  \"ghost\"\n];\n\nconst effectBitmasks = {};\nfor (let i = 0; i < effectNames.length; i++) {\n  effectBitmasks[effectNames[i]] = 1 << i;\n}\n\nexport { effectNames, effectBitmasks };\n","import { SpriteShader, PenLineShader } from \"./Shaders.js\";\nimport { effectNames, effectBitmasks } from \"./effectInfo.js\";\n\n// Everything contained in a shader. It contains both the program, and the locations of the shader inputs.\nclass Shader {\n  constructor(gl, program) {\n    this.gl = gl;\n    this.program = program;\n    this._uniformLocations = new Map();\n    this._attribLocations = new Map();\n\n    const numActiveUniforms = gl.getProgramParameter(\n      program,\n      gl.ACTIVE_UNIFORMS\n    );\n    for (let i = 0; i < numActiveUniforms; i++) {\n      const uniformInfo = gl.getActiveUniform(program, i);\n      this._uniformLocations.set(\n        uniformInfo.name,\n        gl.getUniformLocation(program, uniformInfo.name)\n      );\n    }\n\n    const numActiveAttributes = gl.getProgramParameter(\n      program,\n      gl.ACTIVE_ATTRIBUTES\n    );\n    for (let i = 0; i < numActiveAttributes; i++) {\n      const attribInfo = gl.getActiveAttrib(program, i);\n      this._attribLocations.set(\n        attribInfo.name,\n        gl.getAttribLocation(program, attribInfo.name)\n      );\n    }\n  }\n\n  // In order to pass a value into a shader as an attribute or uniform, you need to know its location.\n  // That's what these two functions do. You give them the name of an attribute or uniform,\n  // and they tell you where the attribute or uniform is located so you can specify its value.\n  attrib(attribName) {\n    return this._attribLocations.get(attribName);\n  }\n\n  uniform(uniformName) {\n    return this._uniformLocations.get(uniformName);\n  }\n}\n\nclass ShaderManager {\n  constructor(renderer) {\n    this.renderer = renderer;\n    this.gl = renderer.gl;\n\n    this._shaderCache = {};\n    for (const drawMode of Object.keys(ShaderManager.DrawModes)) {\n      this._shaderCache[drawMode] = new Map();\n    }\n  }\n\n  // Creates and compiles a vertex or fragment shader from the given source code.\n  _createShader(source, type) {\n    const gl = this.gl;\n    const shader = gl.createShader(type);\n    gl.shaderSource(shader, source);\n    gl.compileShader(shader);\n\n    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n      const info = gl.getShaderInfoLog(shader);\n      throw \"Could not compile WebGL program. \\n\" + info;\n    }\n\n    return shader;\n  }\n\n  getShader(drawMode, effectBitmask = 0) {\n    const gl = this.gl;\n    const shaderMap = this._shaderCache[drawMode];\n    if (shaderMap.has(effectBitmask)) {\n      return shaderMap.get(effectBitmask);\n    } else {\n      let shaderCode;\n      switch (drawMode) {\n        case ShaderManager.DrawModes.DEFAULT:\n        case ShaderManager.DrawModes.SILHOUETTE:\n        case ShaderManager.DrawModes.COLOR_MASK: {\n          shaderCode = SpriteShader;\n          break;\n        }\n\n        case ShaderManager.DrawModes.PEN_LINE: {\n          shaderCode = PenLineShader;\n          break;\n        }\n      }\n\n      // Use #define statements for conditional compilation in shader code.\n      let define = `#define DRAW_MODE_${drawMode}\\n`;\n\n      // Add #defines for each enabled effect.\n      for (let i = 0; i < effectNames.length; i++) {\n        const effectName = effectNames[i];\n        if ((effectBitmask & effectBitmasks[effectName]) !== 0) {\n          define += `#define EFFECT_${effectName}\\n`;\n        }\n      }\n\n      const vertShader = this._createShader(\n        define + shaderCode.vertex,\n        gl.VERTEX_SHADER\n      );\n      const fragShader = this._createShader(\n        define + shaderCode.fragment,\n        gl.FRAGMENT_SHADER\n      );\n\n      // Combine the vertex and fragment shaders into a single GL program.\n      const program = gl.createProgram();\n      gl.attachShader(program, vertShader);\n      gl.attachShader(program, fragShader);\n      gl.linkProgram(program);\n\n      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n        const info = gl.getProgramInfoLog(program);\n        throw new Error(\"Could not compile WebGL program. \\n\" + info);\n      }\n\n      const shader = new Shader(gl, program);\n      shaderMap.set(effectBitmask, shader);\n      return shader;\n    }\n  }\n}\n\nShaderManager.DrawModes = {\n  DEFAULT: \"DEFAULT\",\n  PEN_LINE: \"PEN_LINE\",\n  SILHOUETTE: \"SILHOUETTE\",\n  COLOR_MASK: \"COLOR_MASK\"\n};\n\n// TODO: effects.\n\nexport default ShaderManager;\n","import Skin from \"./Skin.js\";\nimport ShaderManager from \"./ShaderManager.js\";\n\nexport default class PenSkin extends Skin {\n  constructor(renderer, width, height) {\n    super(renderer);\n    this.width = width;\n    this.height = height;\n\n    const framebufferInfo = renderer._createFramebufferInfo(\n      width,\n      height,\n      this.gl.NEAREST\n    );\n    this._framebufferInfo = framebufferInfo;\n\n    this._lastPenState = {\n      size: 0,\n      color: [0, 0, 0, 0]\n    };\n\n    this.clear();\n  }\n\n  destroy() {\n    const gl = this.gl;\n    gl.deleteTexture(this._framebufferInfo.texture);\n    gl.deleteFramebuffer(this._framebufferInfo.framebuffer);\n  }\n\n  getTexture() {\n    return this._framebufferInfo.texture;\n  }\n\n  penLine(pt1, pt2, color, size) {\n    const renderer = this.renderer;\n    renderer._setFramebuffer(this._framebufferInfo);\n\n    const shader = renderer._shaderManager.getShader(\n      ShaderManager.DrawModes.PEN_LINE\n    );\n\n    const gl = this.gl;\n\n    // Set the shader, and check if it actually changed.\n    const shaderChanged = renderer._setShader(shader);\n\n    // These uniforms only need to be set if the shader actually changed.\n    if (shaderChanged) {\n      gl.uniform2f(shader.uniform(\"u_penSkinSize\"), this.width, this.height);\n    }\n\n    // Only set the pen color if it changed or the shader changed.\n    const penColor = color.toRGBANormalized();\n    const oldColor = this._lastPenState.color;\n    if (\n      shaderChanged ||\n      penColor[0] !== oldColor[0] ||\n      penColor[1] !== oldColor[1] ||\n      penColor[2] !== oldColor[2] ||\n      penColor[3] !== oldColor[3]\n    ) {\n      this._lastPenState.color = penColor;\n      gl.uniform4fv(shader.uniform(\"u_penColor\"), penColor);\n    }\n\n    // Only set the pen size if it changed or the shader changed.\n    if (shaderChanged || this._lastPenState.size !== size) {\n      this._lastPenState.size = size;\n      gl.uniform1f(shader.uniform(\"u_penSize\"), size);\n    }\n\n    gl.uniform4f(shader.uniform(\"u_penPoints\"), pt1.x, pt1.y, pt2.x, pt2.y);\n\n    gl.drawArrays(gl.TRIANGLES, 0, 6);\n  }\n\n  clear() {\n    this.renderer._setFramebuffer(this._framebufferInfo);\n    const gl = this.gl;\n    gl.clearColor(0, 0, 0, 0);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n  }\n}\n","export default class Rectangle {\n  constructor() {\n    this.left = -Infinity;\n    this.right = Infinity;\n    this.bottom = -Infinity;\n    this.top = Infinity;\n\n    return this;\n  }\n\n  static fromBounds(left, right, bottom, top, result) {\n    if (!result) result = new Rectangle();\n    result.left = left;\n    result.right = right;\n    result.bottom = bottom;\n    result.top = top;\n\n    return result;\n  }\n\n  // Initialize a bounding box around a sprite given the sprite's transform matrix.\n  static fromMatrix(matrix, result) {\n    if (!result) result = new Rectangle();\n\n    // Adapted somewhat from https://github.com/LLK/scratch-render/blob/develop/docs/Rectangle-AABB-Matrix.md\n    const xa = matrix[0] / 2;\n    const xb = matrix[3] / 2;\n    const absx = Math.abs(xa) + Math.abs(xb);\n    const sumx = xa + xb + matrix[6];\n\n    const ya = matrix[1] / 2;\n    const yb = matrix[4] / 2;\n    const absy = Math.abs(ya) + Math.abs(yb);\n    const sumy = ya + yb + matrix[7];\n\n    result.left = sumx - absx;\n    result.right = sumx + absx;\n    result.bottom = sumy - absy;\n    result.top = sumy + absy;\n\n    return result;\n  }\n\n  // Push this rectangle out to integer bounds.\n  // This takes a conservative approach and will always expand the rectangle outwards.\n  snapToInt() {\n    this.left = Math.floor(this.left);\n    this.right = Math.ceil(this.right);\n    this.bottom = Math.floor(this.bottom);\n    this.top = Math.ceil(this.top);\n\n    return this;\n  }\n\n  // Check whether any part of this rectangle touches another rectangle.\n  intersects(rect) {\n    return (\n      this.left <= rect.right &&\n      rect.left <= this.right &&\n      this.top >= rect.bottom &&\n      rect.top >= this.bottom\n    );\n  }\n\n  // Check whether a given point is inside this rectangle.\n  containsPoint(x, y) {\n    return (\n      x >= this.left && x <= this.right && y >= this.bottom && y <= this.top\n    );\n  }\n\n  // Clamp this rectangle within bounds.\n  clamp(left, right, bottom, top) {\n    this.left = Math.min(Math.max(this.left, left), right);\n    this.right = Math.max(Math.min(this.right, right), left);\n    this.bottom = Math.min(Math.max(this.bottom, bottom), top);\n    this.top = Math.max(Math.min(this.top, top), bottom);\n\n    return this;\n  }\n\n  // Compute the union of two rectangles.\n  static union(rect1, rect2, result = new Rectangle()) {\n    result.left = Math.min(rect1.left, rect2.left);\n    result.right = Math.max(rect1.right, rect2.right);\n    result.bottom = Math.min(rect1.bottom, rect2.bottom);\n    result.top = Math.max(rect1.top, rect2.top);\n\n    return result;\n  }\n\n  // Compute the intersection of two rectangles.\n  static intersection(rect1, rect2, result = new Rectangle()) {\n    result.left = Math.max(rect1.left, rect2.left);\n    result.right = Math.min(rect1.right, rect2.right);\n    result.bottom = Math.max(rect1.bottom, rect2.bottom);\n    result.top = Math.min(rect1.top, rect2.top);\n\n    return result;\n  }\n\n  get width() {\n    return this.right - this.left;\n  }\n\n  get height() {\n    return this.top - this.bottom;\n  }\n}\n","import Skin from \"./Skin.js\";\n\nexport default class BitmapSkin extends Skin {\n  constructor(renderer, image) {\n    super(renderer);\n\n    this._image = image;\n    this._texture = null;\n\n    this._setSizeFromImage(image);\n  }\n\n  getTexture() {\n    // Make sure to handle potentially non-loaded textures\n    const image = this._image;\n    if (!image.complete) return null;\n\n    if (this._texture === null) {\n      // Use nearest-neighbor (i.e. blocky) texture filtering for bitmaps\n      this._texture = super._makeTexture(image, this.gl.NEAREST);\n    }\n    return this._texture;\n  }\n\n  destroy() {\n    if (this._texture !== null) this.gl.deleteTexture(this._texture);\n  }\n}\n","import Skin from \"./Skin.js\";\n\nconst bubbleStyle = {\n  maxLineWidth: 170,\n  minWidth: 50,\n  strokeWidth: 4,\n  padding: 12,\n  tailHeight: 12\n};\n\n// TODO: multiline speech bubbles\nexport default class SpeechBubbleSkin extends Skin {\n  constructor(renderer, bubble) {\n    super(renderer);\n\n    this._canvas = document.createElement(\"canvas\");\n    this._texture = this._makeTexture(null, this.gl.LINEAR);\n    this._bubble = bubble;\n    this._flipped = false;\n    this._rendered = false;\n    this._renderedScale = 0;\n\n    this.width = 0;\n    this.height = 0;\n    this.offsetX = -bubbleStyle.strokeWidth / 2;\n    this.offsetY = this.offsetX + bubbleStyle.tailHeight;\n\n    this._renderBubble(this._bubble);\n  }\n\n  // To ensure proper text measurement and drawing, it's necessary to restyle the canvas after resizing it.\n  _restyleCanvas() {\n    const ctx = this._canvas.getContext(\"2d\");\n    ctx.font = \"16px sans-serif\";\n    ctx.textBaseline = \"hanging\";\n  }\n\n  set flipped(flipped) {\n    this._flipped = flipped;\n    this._rendered = false;\n  }\n\n  _renderBubble(bubble, scale) {\n    const canvas = this._canvas;\n    const ctx = canvas.getContext(\"2d\");\n\n    const renderBubbleBackground = (x, y, w, h, r, style) => {\n      if (r > w / 2) r = w / 2;\n      if (r > h / 2) r = h / 2;\n      if (r < 0) return;\n\n      ctx.beginPath();\n      ctx.moveTo(x + r, y);\n      ctx.arcTo(x + w, y, x + w, y + h, r);\n      ctx.arcTo(x + w, y + h, x + r, y + h, r);\n      if (style === \"say\") {\n        ctx.lineTo(Math.min(x + 3 * r, x + w - r), y + h);\n        ctx.lineTo(x + r / 2, y + h + r);\n        ctx.lineTo(x + r, y + h);\n      } else if (style === \"think\") {\n        ctx.ellipse(x + r * 2.25, y + h, (r * 3) / 4, r / 2, 0, 0, Math.PI);\n      }\n      ctx.arcTo(x, y + h, x, y, r);\n      ctx.arcTo(x, y, x + w, y, r);\n      ctx.closePath();\n      ctx.stroke();\n      ctx.fill();\n\n      if (style === \"think\") {\n        ctx.beginPath();\n        ctx.ellipse(\n          x + r,\n          y + h + (r * 3) / 4,\n          r / 3,\n          r / 3,\n          0,\n          0,\n          2 * Math.PI\n        );\n        ctx.stroke();\n        ctx.fill();\n      }\n    };\n\n    this._restyleCanvas();\n\n    const { text, style } = bubble;\n    const textWidth = ctx.measureText(text).width;\n\n    const maxWidth = bubbleStyle.maxLineWidth;\n    const padding = bubbleStyle.padding;\n\n    const width = Math.ceil(Math.min(textWidth, maxWidth) + 2 * padding);\n    const height = 10 + 2 * padding;\n\n    this.width = width + bubbleStyle.strokeWidth;\n    this.height = height + bubbleStyle.tailHeight + bubbleStyle.strokeWidth;\n\n    canvas.width = this.width * scale;\n    canvas.height = this.height * scale;\n\n    this._restyleCanvas();\n\n    const x = bubbleStyle.strokeWidth / 2;\n    const y = x;\n\n    ctx.setTransform(scale, 0, 0, scale, 0, 0);\n\n    ctx.fillStyle = \"#fff\";\n    ctx.strokeStyle = \"#ccc\";\n    ctx.lineWidth = bubbleStyle.strokeWidth;\n    ctx.save();\n    if (this._flipped) {\n      ctx.scale(-1, 1);\n      ctx.translate(-this.width, 0);\n    }\n    renderBubbleBackground(x, y, width, height, bubbleStyle.tailHeight, style);\n    ctx.restore();\n\n    ctx.fillStyle = \"#444\";\n    ctx.fillText(text, x + padding, y + padding, maxWidth);\n\n    this._rendered = true;\n    this._renderedScale = scale;\n  }\n\n  getTexture(scale) {\n    if (!this._rendered || this._renderedScale !== scale) {\n      this._renderBubble(this._bubble, scale);\n      const gl = this.gl;\n      gl.bindTexture(gl.TEXTURE_2D, this._texture);\n      gl.texImage2D(\n        gl.TEXTURE_2D,\n        0,\n        gl.RGBA,\n        gl.RGBA,\n        gl.UNSIGNED_BYTE,\n        this._canvas\n      );\n    }\n\n    return this._texture;\n  }\n\n  destroy() {\n    this.gl.deleteTexture(this._texture);\n  }\n}\n","import Skin from \"./Skin.js\";\n\n// This means that the smallest mipmap will be 1/(2**4)th the size of the sprite's \"100%\" size.\nconst MIPMAP_OFFSET = 4;\n\nexport default class VectorSkin extends Skin {\n  constructor(renderer, image) {\n    super(renderer);\n\n    this._image = image;\n    this._canvas = document.createElement(\"canvas\");\n\n    this._maxTextureSize = renderer.gl.getParameter(\n      renderer.gl.MAX_TEXTURE_SIZE\n    );\n\n    this._setSizeFromImage(image);\n\n    this._mipmaps = new Map();\n  }\n\n  // TODO: handle proper subpixel positioning when SVG viewbox has non-integer coordinates\n  // This will require rethinking costume + project loading probably\n  _createMipmap(mipLevel) {\n    const scale = 2 ** (mipLevel - MIPMAP_OFFSET);\n\n    // Instead of uploading the image to WebGL as a texture, render the image to a canvas and upload the canvas.\n    const canvas = this._canvas;\n    const ctx = canvas.getContext(\"2d\");\n\n    const image = this._image;\n    let width = image.naturalWidth * scale;\n    let height = image.naturalHeight * scale;\n\n    width = Math.round(Math.min(width, this._maxTextureSize));\n    height = Math.round(Math.min(height, this._maxTextureSize));\n\n    // Prevent IndexSizeErrors if the image is too small to render\n    if (width === 0 || height === 0) {\n      this._mipmaps.set(mipLevel, null);\n      return;\n    }\n\n    canvas.width = width;\n    canvas.height = height;\n\n    ctx.drawImage(image, 0, 0, width, height);\n\n    // Use linear (i.e. smooth) texture filtering for vectors\n    this._mipmaps.set(mipLevel, this._makeTexture(canvas, this.gl.LINEAR));\n  }\n\n  getTexture(scale) {\n    const image = this._image;\n    if (!image.complete) return null;\n\n    // Because WebGL doesn't support vector graphics, substitute a bunch of bitmaps.\n    // This skin contains several renderings of its image at different scales.\n    // We render the SVG at 0.5x scale, 1x scale, 2x scale, 4x scale, etc. and store those as textures,\n    // so we can use the properly-sized texture for whatever scale we're currently rendering at.\n    // Math.ceil(Math.log2(scale)) means we use the \"2x\" texture at 1x-2x scale, the \"4x\" texture at 2x-4x scale, etc.\n    // This means that one texture pixel will always be between 0.5x and 1x the size of one rendered pixel,\n    // but never bigger than one rendered pixel--this prevents blurriness from blowing up the texture too much.\n    const mipLevel = Math.max(Math.ceil(Math.log2(scale)) + MIPMAP_OFFSET, 0);\n    if (!this._mipmaps.has(mipLevel)) this._createMipmap(mipLevel);\n\n    return this._mipmaps.get(mipLevel);\n  }\n\n  destroy() {\n    for (const mip of this._mipmaps.values()) {\n      this.gl.deleteTexture(mip);\n    }\n  }\n}\n","export default class Costume {\n  constructor(name, url, center = { x: 0, y: 0 }) {\n    this.name = name;\n    this.url = url;\n\n    this.img = new Image();\n    this.img.crossOrigin = \"Anonymous\";\n    this.img.src = this.url;\n\n    // TODO: this is super janky, but fixing this fully requires restructuring costume loading\n    this.isBitmap = !this.url.match(/\\.svg/);\n    this.resolution = this.isBitmap ? 2 : 1;\n\n    this.center = center;\n  }\n\n  get width() {\n    return this.img.naturalWidth;\n  }\n\n  get height() {\n    return this.img.naturalHeight;\n  }\n}\n","import BitmapSkin from \"./BitmapSkin.js\";\nimport SpeechBubbleSkin from \"./SpeechBubbleSkin.js\";\nimport VectorSkin from \"./VectorSkin.js\";\n\nimport Costume from \"../Costume.js\";\n\n// This is a class which manages the creation and destruction of Skin objects.\n// A Skin is the renderer's version of a \"costume\". It is backed by an image, but you render it by getting its texture.\n// Different types of Skins can give you textures in different ways.\nexport default class SkinCache {\n  constructor(renderer) {\n    this._renderer = renderer;\n    this.gl = renderer.gl;\n\n    this._skins = new Map();\n  }\n\n  // Begin GC tracing. Any skin retrieved and rendered during tracing will *not* be garbage-collected.\n  beginTrace() {\n    // Initialize by assuming no texture is used.\n    this._skins.forEach(skin => {\n      skin.used = false;\n    });\n  }\n\n  // End GC tracing. Any skin not retrieved since the tracing begun will be deleted.\n  endTrace() {\n    this._skins.forEach((skin, key) => {\n      if (!skin.used) {\n        skin.destroy();\n        this._skins.delete(key);\n      }\n    });\n  }\n\n  // Retrieve a given object (e.g. costume or speech bubble)'s skin. If it doesn't exist, make one.\n  getSkin(obj) {\n    if (this._skins.has(obj)) {\n      const skin = this._skins.get(obj);\n      skin.used = true;\n      return skin;\n    } else {\n      let skin;\n\n      if (obj instanceof Costume) {\n        if (obj.isBitmap) {\n          skin = new BitmapSkin(this._renderer, obj.img);\n        } else {\n          skin = new VectorSkin(this._renderer, obj.img);\n        }\n      } else {\n        // If it's not a costume, assume it's a speech bubble.\n        skin = new SpeechBubbleSkin(this._renderer, obj);\n      }\n      this._skins.set(obj, skin);\n      return skin;\n    }\n  }\n}\n","const clamp = (n, min, max) => Math.max(min, Math.min(max, n));\n\n// https://www.rapidtables.com/convert/color/rgb-to-hsv.html\nfunction rgbToHSV(r, g, b) {\n  r /= 255;\n  g /= 255;\n  b /= 255;\n\n  const max = Math.max(r, g, b);\n  const min = Math.min(r, g, b);\n  const delta = max - min;\n\n  let h = 0;\n  if (delta === 0) {\n    // Grey. Leave at 0.\n  } else if (max === r) {\n    h = (((g - b) / delta + 6) % 6) / 6;\n  } else if (max === g) {\n    h = (((b - r) / delta + 2) % 6) / 6;\n  } else if (max === b) {\n    h = (((r - g) / delta + 4) % 6) / 6;\n  }\n\n  let s = 0;\n  if (max !== 0) {\n    s = delta / max;\n  }\n\n  let v = max;\n\n  return {\n    h: h * 100,\n    s: s * 100,\n    v: v * 100\n  };\n}\n\n// https://www.rapidtables.com/convert/color/hsv-to-rgb.html\nfunction hsvToRGB(h, s, v) {\n  h = (h / 100) * 360;\n  s /= 100;\n  v /= 100;\n\n  const c = v * s;\n  const x = c * (1 - Math.abs(((h / 60) % 2) - 1));\n\n  const min = v - c;\n\n  let r = min;\n  let g = min;\n  let b = min;\n\n  if (h < 60) {\n    r += c;\n    g += x;\n  } else if (h < 120) {\n    g += c;\n    r += x;\n  } else if (h < 180) {\n    g += c;\n    b += x;\n  } else if (h < 240) {\n    b += c;\n    g += x;\n  } else if (h < 300) {\n    b += c;\n    r += x;\n  } else if (h < 360) {\n    r += c;\n    b += x;\n  }\n\n  return {\n    r: r * 255,\n    g: g * 255,\n    b: b * 255\n  };\n}\n\nexport default class Color {\n  constructor(h = 0, s = 0, v = 0, a = 1) {\n    this.h = h;\n    this.s = s;\n    this.v = v;\n    this.a = a;\n  }\n\n  static rgb(r, g, b, a = 1) {\n    const { h, s, v } = rgbToHSV(r, g, b);\n    return new Color(h, s, v, a);\n  }\n\n  static hsv(h, s, v, a = 1) {\n    return new Color(h, s, v, a);\n  }\n\n  static num(n) {\n    n = Number(n);\n\n    // Match Scratch rgba system\n    // https://github.com/LLK/scratch-vm/blob/0dffc65ce99307d048f6b9a10b1c31b01ab0133d/src/util/color.js#L45\n    const a = (n >> 24) & 0xff;\n    const r = (n >> 16) & 0xff;\n    const g = (n >> 8) & 0xff;\n    const b = n & 0xff;\n    return Color.rgb(r, g, b, a > 0 ? a / 255 : 1);\n  }\n\n  // Red\n  get r() {\n    return hsvToRGB(this.h, this.s, this.v).r;\n  }\n  set r(r) {\n    this._setRGB(r, this.g, this.b);\n  }\n\n  // Green\n  get g() {\n    return hsvToRGB(this.h, this.s, this.v).g;\n  }\n  set g(g) {\n    this._setRGB(this.r, g, this.b);\n  }\n\n  // Blue\n  get b() {\n    return hsvToRGB(this.h, this.s, this.v).b;\n  }\n  set b(b) {\n    this._setRGB(this.r, this.g, b);\n  }\n\n  // Alpha\n  get a() {\n    return this._a;\n  }\n  set a(a) {\n    this._a = clamp(a, 0, 1);\n  }\n\n  // Hue\n  get h() {\n    return this._h;\n  }\n  set h(h) {\n    this._h = ((h % 100) + 100) % 100;\n  }\n\n  // Shade\n  get s() {\n    return this._s;\n  }\n  set s(s) {\n    this._s = clamp(s, 0, 100);\n  }\n\n  // Value\n  get v() {\n    return this._v;\n  }\n  set v(v) {\n    this._v = clamp(v, 0, 100);\n  }\n\n  _setRGB(r, g, b) {\n    r = clamp(r, 0, 255);\n    g = clamp(g, 0, 255);\n    b = clamp(b, 0, 255);\n\n    const { h, s, v } = rgbToHSV(r, g, b);\n\n    this.h = h;\n    this.s = s;\n    this.v = v;\n  }\n\n  toHexString(forceIncludeAlpha = false) {\n    const toHexDigits = n => {\n      n = clamp(Math.round(n), 0, 255);\n\n      let str = n.toString(16);\n      if (str.length === 1) {\n        str = \"0\" + str;\n      }\n\n      return str;\n    };\n\n    let hex = \"#\" + [this.r, this.g, this.b].map(toHexDigits).join(\"\");\n    if (forceIncludeAlpha || this.a !== 1) {\n      hex += toHexDigits(this.a * 255);\n    }\n\n    return hex;\n  }\n\n  toRGBString(forceIncludeAlpha = false) {\n    const rgb = [this.r, this.g, this.b].map(Math.round);\n\n    if (forceIncludeAlpha || this.a !== 1) {\n      return `rgba(${rgb.join(\", \")}, ${this.a})`;\n    }\n    return `rgb(${rgb.join(\", \")})`;\n  }\n\n  toRGBA() {\n    const rgb = hsvToRGB(this._h, this._s, this._v);\n    return [rgb.r, rgb.g, rgb.b, this._a * 255];\n  }\n\n  toRGBANormalized() {\n    const rgb = hsvToRGB(this._h, this._s, this._v);\n    return [rgb.r / 255, rgb.g / 255, rgb.b / 255, this._a];\n  }\n\n  toString() {\n    return this.toRGBString();\n  }\n}\n","/**\n * The MIT License (MIT)\n *\n * Copyright (c) 2013-2019 Truman Kilen, Nathan Dinsmore, and Adroitwhiz\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n// prettier-ignore\nconst ADPCM_STEPS = [\n  7, 8, 9, 10, 11, 12, 13, 14, 16, 17, 19, 21, 23, 25, 28, 31, 34, 37, 41, 45, 50, 55, 60, 66, 73, 80, 88, 97, 107,\n  118, 130, 143, 157, 173, 190, 209, 230, 253, 279, 307, 337, 371, 408, 449, 494, 544, 598, 658, 724, 796, 876, 963,\n  1060, 1166, 1282, 1411, 1552, 1707, 1878, 2066, 2272, 2499, 2749, 3024, 3327, 3660, 4026, 4428, 4871, 5358, 5894,\n  6484, 7132, 7845, 8630, 9493, 10442, 11487, 12635, 13899, 15289, 16818, 18500, 20350, 22385, 24623, 27086, 29794,\n  32767\n];\n\nconst ADPCM_INDEX = [-1, -1, -1, -1, 2, 4, 6, 8, -1, -1, -1, -1, 2, 4, 6, 8];\n\nexport default function decodeADPCMAudio(ab, audioContext) {\n  const dv = new DataView(ab);\n  // WAV magic number\n  if (dv.getUint32(0) !== 0x52494646 || dv.getUint32(8) !== 0x57415645) {\n    return Promise.reject(new Error(\"Unrecognized audio format\"));\n  }\n\n  const blocks = {};\n  const l = dv.byteLength - 8;\n  let i = 12;\n  while (i < l) {\n    blocks[\n      String.fromCharCode(\n        dv.getUint8(i),\n        dv.getUint8(i + 1),\n        dv.getUint8(i + 2),\n        dv.getUint8(i + 3)\n      )\n    ] = i;\n    i += 8 + dv.getUint32(i + 4, true);\n  }\n\n  const format = dv.getUint16(20, true);\n  const sampleRate = dv.getUint32(24, true);\n\n  if (format === 17) {\n    const samplesPerBlock = dv.getUint16(38, true);\n    const blockSize = (samplesPerBlock - 1) / 2 + 4;\n\n    const frameCount = dv.getUint32(blocks.fact + 8, true);\n\n    const buffer = audioContext.createBuffer(1, frameCount, sampleRate);\n    const channel = buffer.getChannelData(0);\n\n    let sample;\n    let index = 0;\n    let step, code, delta;\n    let lastByte = -1;\n\n    const offset = blocks.data + 8;\n    let i = offset;\n    let j = 0;\n    // eslint-disable-next-line\n    while (true) {\n      if ((i - offset) % blockSize === 0 && lastByte < 0) {\n        if (i >= dv.byteLength) break;\n        sample = dv.getInt16(i, true);\n        i += 2;\n        index = dv.getUint8(i);\n        i += 1;\n        i++;\n        if (index > 88) index = 88;\n        channel[j++] = sample / 32767;\n      } else {\n        if (lastByte < 0) {\n          if (i >= dv.byteLength) break;\n          lastByte = dv.getUint8(i);\n          i += 1;\n          code = lastByte & 0xf;\n        } else {\n          code = (lastByte >> 4) & 0xf;\n          lastByte = -1;\n        }\n        step = ADPCM_STEPS[index];\n        delta = 0;\n        if (code & 4) delta += step;\n        if (code & 2) delta += step >> 1;\n        if (code & 1) delta += step >> 2;\n        delta += step >> 3;\n        index += ADPCM_INDEX[code];\n        if (index > 88) index = 88;\n        if (index < 0) index = 0;\n        sample += code & 8 ? -delta : delta;\n        if (sample > 32767) sample = 32767;\n        if (sample < -32768) sample = -32768;\n        channel[j++] = sample / 32768;\n      }\n    }\n    return Promise.resolve(buffer);\n  }\n  return Promise.reject(new Error(`Unrecognized WAV format ${format}`));\n}\n\nexport function isWavData(arrayBuffer) {\n  const dataView = new DataView(arrayBuffer);\n  return (\n    dataView.getUint32(0) === 0x52494646 && dataView.getUint32(8) === 0x57415645\n  );\n}\n\nexport function isADPCMData(arrayBuffer) {\n  const dataView = new DataView(arrayBuffer);\n  const format = dataView.getUint16(20, true);\n  return isWavData(arrayBuffer) && format === 17;\n}\n","import decodeADPCMAudio, { isADPCMData } from \"./lib/decode-adpcm-audio.js\";\n\nexport default class Sound {\n  constructor(name, url) {\n    this.name = name;\n    this.url = url;\n\n    this.audioBuffer = null;\n    this.source = null;\n    this.playbackRate = 1;\n\n    // TODO: Remove this line; initiate downloads from somewhere else instead.\n    this.downloadMyAudioBuffer();\n  }\n\n  get duration() {\n    return this.audioBuffer.duration;\n  }\n\n  *start() {\n    let started = false;\n    let isLatestCallToStart = true;\n\n    if (this._markDone) {\n      this._markDone();\n    }\n\n    if (this.audioBuffer) {\n      this.playMyAudioBuffer();\n      started = true;\n    } else {\n      // It's possible that start() will be called again before this start()\n      // has successfully started the sound (i.e. because it was waiting for\n      // the audio buffer to download). If that's the case, _doneDownloading\n      // will already exist. We never want to return from start() before the\n      // sound has begun playing, but in the case of playUntilDone(), only the\n      // latest call should wait for the sound to finish playing; also, we only\n      // need to run playMyAudioBuffer once. To meet all these conditions, and\n      // also to avoid implementing some kind of addEventListener-esque system,\n      // we implement a simple \"listener chain\" here. Every time we set call\n      // start(), we keep track of the previous value of doneDownloading, and\n      // replace it with a new function. When this function is called directly\n      // as a result of the download finishing, it will call, if existent, the\n      // previous value of doneDownloading with a flag indicating it is being\n      // called from a more recent call to start(). That function will in turn\n      // do the same for its saved previous value, and so on, until all the\n      // previous values of doneDownloading have been called. Thus, all\n      // previous calls of start() will then finish, returning their value of\n      // isLatestCallToStart: false, indicating that if the call came from\n      // playUntilDone(), that playUntilDone should not wait for the sound to\n      // finish playing. Of course, the latest call returns true, and so the\n      // containing playUntilDone() (if present) knows to wait.\n      const oldDoneDownloading = this._doneDownloading;\n      this._doneDownloading = fromMoreRecentCall => {\n        if (fromMoreRecentCall) {\n          isLatestCallToStart = false;\n        } else {\n          this.playMyAudioBuffer();\n          started = true;\n          delete this._doneDownloading;\n        }\n        if (oldDoneDownloading) {\n          oldDoneDownloading(true);\n        }\n      };\n    }\n\n    while (!started && isLatestCallToStart) yield;\n\n    return isLatestCallToStart;\n  }\n\n  *playUntilDone() {\n    let playing = true;\n\n    const isLatestCallToStart = yield* this.start();\n\n    // If we failed to download the audio buffer, just stop here - the sound will\n    // never play, so it doesn't make sense to wait for it.\n    if (!this.audioBuffer) {\n      return;\n    }\n\n    this.source.addEventListener(\"ended\", () => {\n      playing = false;\n      delete this._markDone;\n    });\n\n    // If there was another call to start() since ours, don't wait for the\n    // sound to finish before returning.\n    if (!isLatestCallToStart) {\n      return;\n    }\n\n    // Set _markDone after calling start(), because start() will call the existing\n    // value of _markDone if it's already set. It does this because playUntilDone()\n    // is meant to be interrupted if another start() is ran while it's playing.\n    // Of course, we don't want *this* playUntilDone() to be treated as though it\n    // were interrupted when we call start(), so setting _markDone comes after.\n    this._markDone = () => {\n      playing = false;\n      delete this._markDone;\n    };\n\n    while (playing) yield;\n  }\n\n  stop() {\n    if (this._markDone) {\n      this._markDone();\n    }\n\n    if (this.source) {\n      this.source.disconnect();\n      this.source = null;\n    }\n  }\n\n  downloadMyAudioBuffer() {\n    return fetch(this.url)\n      .then(body => body.arrayBuffer())\n      .then(arrayBuffer => {\n        if (isADPCMData(arrayBuffer)) {\n          return decodeADPCMAudio(arrayBuffer, Sound.audioContext).catch(\n            error => {\n              console.warn(\n                `Failed to load sound \"${this.name}\" - will not play:\\n` + error\n              );\n              return null;\n            }\n          );\n        } else {\n          return new Promise((resolve, reject) => {\n            Sound.audioContext.decodeAudioData(arrayBuffer, resolve, reject);\n          });\n        }\n      })\n      .then(audioBuffer => {\n        this.audioBuffer = audioBuffer;\n        if (this._doneDownloading) {\n          this._doneDownloading();\n        }\n        return audioBuffer;\n      });\n  }\n\n  playMyAudioBuffer() {\n    if (!this.audioBuffer) {\n      return;\n    }\n\n    if (this.source) {\n      this.source.disconnect();\n    }\n\n    this.source = Sound.audioContext.createBufferSource();\n    this.source.buffer = this.audioBuffer;\n    this.source.playbackRate.value = this.playbackRate;\n\n    if (this.target) {\n      this.source.connect(this.target);\n    }\n\n    this.source.start(Sound.audioContext.currentTime);\n  }\n\n  connect(target) {\n    if (target !== this.target) {\n      this.target = target;\n      if (this.source) {\n        this.source.disconnect();\n        this.source.connect(this.target);\n      }\n    }\n  }\n\n  setPlaybackRate(value) {\n    this.playbackRate = value;\n    if (this.source) {\n      this.source.playbackRate.value = value;\n    }\n  }\n\n  isConnectedTo(target) {\n    return this.target === target;\n  }\n\n  // Note: \"this\" refers to the Sound class in static functions.\n\n  static get audioContext() {\n    this._setupAudioContext();\n    return this._audioContext;\n  }\n\n  static _setupAudioContext() {\n    if (!this._audioContext) {\n      const AudioContext = window.AudioContext || window.webkitAudioContext;\n      this._audioContext = new AudioContext();\n    }\n  }\n\n  static decodeADPCMAudio(audioBuffer) {\n    return decodeADPCMAudio(audioBuffer, this.audioContext);\n  }\n}\n\nexport class EffectChain {\n  // The code in this class is functionally comparable to the class of the same\n  // name in the scratch-audio library, but is completely rewritten and follows\n  // somewhat different logic. Still, the class exists on the same principle:\n  // a portable way to store the effect chain, independent of the audio sources\n  // it affects.\n\n  constructor(config) {\n    const { getNonPatchSoundList } = config;\n    this.config = config;\n\n    this.inputNode = Sound.audioContext.createGain();\n\n    // This is a mapping of an effect's name to an object containing all the\n    // nodes which are of use to that effect: always an {input, output} pair,\n    // as well as any other nodes of use to that effect. The values here are\n    // filled in by an effect descriptor's makeNodes() function, and may\n    // contain duplicate copies of the same node within a particular effect's\n    // object, when that's of use to make the logic clearer (e.g. when there's\n    // no distinction between the input and output node, or referring to the\n    // output node by a more specific name).\n    this.effectNodes = {};\n\n    this.resetToInitial();\n\n    this.getNonPatchSoundList = getNonPatchSoundList;\n  }\n\n  resetToInitial() {\n    // Note: some effects won't be reset by this function, except for when they\n    // are set for the first time (i.e. when the EffectChain is instantiated).\n    // Look for the \"reset: false\" flag in the effect descriptor list.\n\n    const initials = EffectChain.getInitialEffectValues();\n    if (this.effectValues) {\n      for (const [name, initialValue] of Object.entries(\n        EffectChain.getInitialEffectValues()\n      )) {\n        if (EffectChain.getEffectDescriptor(name).reset !== false) {\n          this.setEffectValue(name, initialValue);\n        }\n      }\n    } else {\n      this.effectValues = initials;\n    }\n  }\n\n  updateAudioEffect(name) {\n    const descriptor = EffectChain.getEffectDescriptor(name);\n\n    if (!descriptor) {\n      return;\n    }\n\n    // updateAudioEffect doesn't take a value - it only reflects the existing\n    // value in the actual effects applied to nodes and sounds!\n    const value = this.effectValues[name];\n\n    if (descriptor.isPatch) {\n      // Here, we search for the next and previous effects in the chain\n      // who have existent nodes. This means we'll skip non-patch effects as\n      // well as effects are set to their initial value.\n\n      let next = descriptor;\n      do {\n        next = EffectChain.getNextEffectDescriptor(next.name);\n      } while (next && !this.effectNodes[next.name]);\n\n      let previous = descriptor;\n      do {\n        previous = EffectChain.getPreviousEffectDescriptor(previous.name);\n      } while (previous && !this.effectNodes[previous.name]);\n\n      // If we have previous and next values available, they'll currently be\n      // the corresponding descriptors. But we only ever need to access the\n      // nodes which correspond to those descriptor's names, so we replace them\n      // with the actual objects containing the effect's nodes here to simplify\n      // later code.\n\n      if (next) {\n        next = this.effectNodes[next.name];\n      }\n\n      if (previous) {\n        next = this.effectNodes[previous.name];\n      }\n\n      // If there is no preceding or following effect which has existent nodes,\n      // we'll make the variables reference the target input and target nodes\n      // of the EffectChain - i.e, the two ends of the chain, as far as this\n      // class is concerned. (Note that while the input node will always be\n      // present, because it's defined right on the EffectChain, it's possible\n      // that there won't be any target node, leaving the value for \"next\"\n      // still null.)\n      //\n      // We do need to keep to the structure that effectNodes contains, though.\n      // When we access the previous node (or the EffectChain's input node, in\n      // this case), we'll be making a connection with its output; likewise,\n      // when we're accessing the next node (or the EffectChain's target),\n      // we'll be connecting something to its input. That's reflected in the\n      // values here.\n\n      if (!previous) {\n        previous = { output: this.inputNode };\n      }\n\n      if (!next && this.target) {\n        next = { input: this.target };\n      }\n\n      // \"Patch\" effects are applied by sending audio data through an ordered\n      // series - i.e, a chain - of WebAudio nodes. All effects have an input\n      // node and an output node; for simple effects, these may actually be the\n      // same node. (Take a look at the volume effect, which uses a single Gain\n      // node as both its input and output.) Other effects are more complex.\n      // The code in this block controls the actual chaining behavior of\n      // EffectChain, assuring that all effects form a clean chain.\n      let nodes = this.effectNodes[descriptor.name];\n      if (!nodes && value !== descriptor.initial) {\n        nodes = descriptor.makeNodes();\n        this.effectNodes[descriptor.name] = nodes;\n\n        // Connect the previous effect, or, if there is none, the EffectChain\n        // input, to this effect. Also disconnect it from whatever it was\n        // previously connected to, so we aren't sending data more than one\n        // place at a time - that would mess with the chain.\n        previous.output.disconnect();\n        previous.output.connect(nodes.input);\n\n        // Connect this effect to the next effect, or, if there is none,\n        // the EffectChain target.\n        if (next) {\n          nodes.output.connect(next.input);\n        }\n      }\n\n      if (value === descriptor.initial) {\n        // If we're setting to the initial value, disconnect and discard the\n        // effect's nodes. It's not necessary to keep nodes that don't cause\n        // an effect in the chain. (We don't need to run the set() behavior\n        // specified on the effect descriptor, since we're disconnecting and\n        // discarding the nodes - the only values that function has access to.)\n        if (nodes) {\n          // There's no need to define custom disposal behavior per effect,\n          // since it's always a matter of simply disconnecting every node.\n          // The disconnect() method of a WebAudio node won't error if it's\n          // already had all its connections removed, but we avoid redundant\n          // calls here anyway.\n          for (const node of new Set(Object.values(nodes))) {\n            node.disconnect();\n          }\n\n          // We also need to establish a connection between the adjacent nodes\n          // (which may be the EffectChain's input node and target node, if\n          // there aren't any adjacent effect nodes).\n          if (next) {\n            previous.output.connect(next.input);\n          }\n\n          // Finally, we discard the object which holds the effect's nodes.\n          // We aren't going to be using it anymore, and we need it gone so\n          // that we recreate the nodes and correctly position them back in\n          // the chain, if we use this effect again later.\n          delete this.effectNodes[name];\n        }\n      } else {\n        descriptor.set(value, nodes);\n      }\n    } else {\n      // Non-\"patch\" effects operate directly on Sound objects, accessing\n      // APIs provided by that class. The actual sound list is provided by the\n      // caller of EffectChain.\n      for (const sound of this.getNonPatchSoundList()) {\n        descriptor.set(value, sound);\n      }\n    }\n  }\n\n  connect(target) {\n    this.target = target;\n\n    // All the code here is basically the same as what's written in\n    // updateAudioEffect above; specific to this function, we want to\n    // disconnect the final output in the chain - which may be the input\n    // node - and then connect it to the newly specified target.\n\n    let last = EffectChain.getLastEffectDescriptor();\n    do {\n      last = EffectChain.getPreviousEffectDescriptor(last.name);\n    } while (last && !this.effectNodes[last.name]);\n\n    if (last) {\n      last = this.effectNodes[last.name];\n    } else {\n      last = { output: this.inputNode };\n    }\n\n    last.output.disconnect();\n    last.output.connect(target);\n  }\n\n  setEffectValue(name, value) {\n    value = Number(value);\n    if (\n      name in this.effectValues &&\n      !isNaN(value) &&\n      value !== this.effectValues[name]\n    ) {\n      this.effectValues[name] = value;\n      this.clampEffectValue(name);\n      this.updateAudioEffect(name);\n    }\n  }\n\n  changeEffectValue(name, value) {\n    value = Number(value);\n    if (name in this.effectValues && !isNaN(value) && value !== 0) {\n      this.effectValues[name] += value;\n      this.clampEffectValue(name);\n      this.updateAudioEffect(name);\n    }\n  }\n\n  clampEffectValue(name) {\n    // Not all effects are clamped (pitch, for example); it's also possible to\n    // specify only a minimum or maximum bound, instead of both.\n    const descriptor = EffectChain.getEffectDescriptor(name);\n    let value = this.effectValues[name];\n    if (\"minimum\" in descriptor && value < descriptor.minimum) {\n      value = descriptor.minimum;\n    } else if (\"maximum\" in descriptor && value > descriptor.maximum) {\n      value = descriptor.maximum;\n    }\n    this.effectValues[name] = value;\n  }\n\n  getEffectValue(name) {\n    return this.effectValues[name] || 0;\n  }\n\n  clone(newConfig) {\n    const newEffectChain = new EffectChain(\n      Object.assign({}, this.config, newConfig)\n    );\n\n    for (const [name, value] of Object.entries(this.effectValues)) {\n      const descriptor = EffectChain.getEffectDescriptor(name);\n      if (!descriptor.resetOnClone) {\n        newEffectChain.setEffectValue(name, value);\n      }\n    }\n\n    newEffectChain.connect(this.target);\n\n    return newEffectChain;\n  }\n\n  applyToSound(sound) {\n    sound.connect(this.inputNode);\n\n    for (const [name, value] of Object.entries(this.effectValues)) {\n      const descriptor = EffectChain.getEffectDescriptor(name);\n      if (!descriptor.isPatch) {\n        descriptor.set(value, sound);\n      }\n    }\n  }\n\n  isTargetOf(sound) {\n    return sound.isConnectedTo(this.inputNode);\n  }\n\n  static getInitialEffectValues() {\n    // This would be an excellent place to use Object.fromEntries, but that\n    // function has been implemented in only the latest of a few modern\n    // browsers. :P\n    const initials = {};\n    for (const { name, initial } of this.effectDescriptors) {\n      initials[name] = initial;\n    }\n    return initials;\n  }\n\n  static getEffectDescriptor(name) {\n    return this.effectDescriptors.find(descriptor => descriptor.name === name);\n  }\n\n  static getFirstEffectDescriptor() {\n    return this.effectDescriptors[0];\n  }\n\n  static getLastEffectDescriptor() {\n    return this.effectDescriptors[this.effectDescriptors.length - 1];\n  }\n\n  static getNextEffectDescriptor(name) {\n    // .find() provides three values to its passed function: the value of the\n    // current item, that item's index, and the array on which .find() is\n    // operating. In this case, we're only concerned with the index.\n    // For each item in the list, besides the first, we check if the item\n    // before it matches the name we were given. By initially shifting all the\n    // descriptors using slice(1), the index of any item in the shifted list\n    // corresponds to the previous item in the original list. Thus, if that\n    // previous item matches the provided name, by definition, we'll have found\n    // the item which comes after it.\n    return this.effectDescriptors\n      .slice(1)\n      .find((_, i) => this.effectDescriptors[i].name === name);\n  }\n\n  static getPreviousEffectDescriptor(name) {\n    // This function's a little simpler, since it doesn't involve shifting the\n    // list. We still use slice(), but this time simply to cut off the last\n    // item; that item will never come before any other, after all. We search\n    // the list for the item whose following item matches the provided name,\n    // using the more typical [i + 1] way of accessing an adjacent item.\n    // (In getNextEffectDescriptor(), we don't need to offset the index like\n    // that, because the shift already lines up the index as we need it.)\n    return this.effectDescriptors\n      .slice(0, -1)\n      .find((_, i) => this.effectDescriptors[i + 1].name === name);\n  }\n}\n\n// These are constant values which can be affected to tweak the way effects\n// are applied. They match the values used in Scratch 3.0.\nEffectChain.decayDuration = 0.025;\nEffectChain.decayWait = 0.05;\n\n// Instead of creating a basic Effect class and then implementing a subclass\n// for each effect type, we use a simplified object-descriptor style.\n// The makeNodes() function returns an object which is passed on to set(), so\n// that effects are able to access a variety of nodes (or other values, if\n// necessary) required to execute the desired effect.\n//\n// The code in makeNodes as well as the general definition for each effect is\n// all graciously based on LLK's scratch-audio library.\n//\n// The initial value of an effect should always be the value at which the\n// sound is not affected at all - i.e, it would be the same if the effect\n// nodes were completely disconnected from the chain or otherwise had never\n// been applied. This allows for clean discarding of effect nodes when returned\n// to the initial value.\n//\n// The order of this array matches AudioEngine's effects list in scratch-audio.\n// Earlier in the list is closer to the EffectChain input node; later is closer\n// to its target (output). Note that a non-\"patch\" effect's position in the\n// array has no bearing on effect behavior, since it isn't part of the chain\n// system.\n//\n// Note that this descriptor list is fairly easy to build on, if we'd like to\n// add more audio effects in the future. (Scratch used to have more, but they\n// were removed - see commit ff6cd4a - because they depended on an external\n// library and were too processor-intensive to support on some devices.)\nEffectChain.effectDescriptors = [\n  {\n    name: \"pan\",\n    initial: 0,\n    minimum: -100,\n    maximum: 100,\n    isPatch: true,\n    makeNodes() {\n      const aCtx = Sound.audioContext;\n      const input = aCtx.createGain();\n      const leftGain = aCtx.createGain();\n      const rightGain = aCtx.createGain();\n      const channelMerger = aCtx.createChannelMerger(2);\n      const output = channelMerger;\n      input.connect(leftGain);\n      input.connect(rightGain);\n      leftGain.connect(channelMerger, 0, 0);\n      rightGain.connect(channelMerger, 0, 1);\n      return { input, output, leftGain, rightGain, channelMerger };\n    },\n    set(value, { input, output, leftGain, rightGain }) {\n      const p = (value + 100) / 200;\n      const leftVal = Math.cos((p * Math.PI) / 2);\n      const rightVal = Math.sin((p * Math.PI) / 2);\n      const { currentTime } = Sound.audioContext;\n      const { decayWait, decayDuration } = EffectChain;\n      leftGain.gain.setTargetAtTime(\n        leftVal,\n        currentTime + decayWait,\n        decayDuration\n      );\n      rightGain.gain.setTargetAtTime(\n        rightVal,\n        currentTime + decayWait,\n        decayDuration\n      );\n    }\n  },\n  {\n    name: \"pitch\",\n    initial: 0,\n    isPatch: false,\n    set(value, sound) {\n      const interval = value / 10;\n      const ratio = Math.pow(2, interval / 12);\n      sound.setPlaybackRate(ratio);\n    }\n  },\n  {\n    name: \"volume\",\n    initial: 100,\n    minimum: 0,\n    maximum: 100,\n    resetOnStart: false,\n    resetOnClone: true,\n    isPatch: true,\n    makeNodes() {\n      const node = Sound.audioContext.createGain();\n      return {\n        input: node,\n        output: node,\n        node\n      };\n    },\n    set(value, { node }) {\n      node.gain.linearRampToValueAtTime(\n        value / 100,\n        Sound.audioContext.currentTime + EffectChain.decayDuration\n      );\n    }\n  }\n];\n\nexport class AudioEffectMap {\n  // This class provides a simple interface for setting and getting audio\n  // effects stored on an EffectChain, similar to EffectMap (that class being\n  // for graphic effects). It takes an EffectChain and automatically generates\n  // properties according to the names of the effect descriptors, acting with\n  // the EffectChain's API when accessed.\n\n  constructor(effectChain) {\n    this.effectChain = effectChain;\n\n    for (const { name } of EffectChain.effectDescriptors) {\n      Object.defineProperty(this, name, {\n        get: () => effectChain.getEffectValue(name),\n        set: value => effectChain.setEffectValue(name, value)\n      });\n    }\n  }\n\n  clear() {\n    this.effectChain.resetToInitial();\n  }\n}\n","import Color from \"./Color.js\";\nimport Trigger from \"./Trigger.js\";\nimport Sound, { EffectChain, AudioEffectMap } from \"./Sound.js\";\n\nimport { effectNames } from \"./renderer/effectInfo.js\";\n// This is a wrapper to allow the enabled effects in a sprite to be used as a Map key.\n// By setting an effect, the bitmask is updated as well.\n// This allows the bitmask to be used to uniquely identify a set of enabled effects.\nclass _EffectMap {\n  constructor() {\n    this._bitmask = 0;\n    this._effectValues = {};\n\n    for (let i = 0; i < effectNames.length; i++) {\n      const effectName = effectNames[i];\n      this._effectValues[effectName] = 0;\n\n      Object.defineProperty(this, effectName, {\n        get: () => {\n          return this._effectValues[effectName];\n        },\n\n        set: val => {\n          this._effectValues[effectName] = val;\n\n          if (val === 0) {\n            // If the effect value is 0, meaning it's disabled, set its bit in the bitmask to 0.\n            this._bitmask = this._bitmask & ~(1 << i);\n          } else {\n            // Otherwise, set its bit to 1.\n            this._bitmask = this._bitmask | (1 << i);\n          }\n        }\n      });\n    }\n  }\n\n  _clone() {\n    const m = new _EffectMap();\n    for (const effectName of Object.keys(this._effectValues)) {\n      m[effectName] = this[effectName];\n    }\n    return m;\n  }\n\n  clear() {\n    for (const effectName of Object.keys(this._effectValues)) {\n      this._effectValues[effectName] = 0;\n    }\n    this._bitmask = 0;\n  }\n}\n\nclass SpriteBase {\n  constructor(initialConditions, vars = {}) {\n    this._project = null;\n\n    const { costumeNumber, layerOrder = 0 } = initialConditions;\n    this._costumeNumber = costumeNumber;\n    this._layerOrder = layerOrder;\n\n    this.triggers = [];\n    this.watchers = {};\n    this.costumes = [];\n    this.sounds = [];\n\n    this.effectChain = new EffectChain({\n      getNonPatchSoundList: this.getSoundsPlayedByMe.bind(this)\n    });\n    this.effectChain.connect(Sound.audioContext.destination);\n\n    this.effects = new _EffectMap();\n    this.audioEffects = new AudioEffectMap(this.effectChain);\n\n    this._vars = vars;\n  }\n\n  getSoundsPlayedByMe() {\n    return this.sounds.filter(sound => this.effectChain.isTargetOf(sound));\n  }\n\n  get stage() {\n    return this._project.stage;\n  }\n\n  get sprites() {\n    return this._project.sprites;\n  }\n\n  get vars() {\n    return this._vars;\n  }\n\n  get costumeNumber() {\n    return this._costumeNumber;\n  }\n\n  set costumeNumber(number) {\n    this._costumeNumber = ((number - 1) % this.costumes.length) + 1;\n  }\n\n  set costume(costume) {\n    if (typeof costume === \"number\") {\n      this.costumeNumber = costume;\n    }\n    if (typeof costume === \"string\") {\n      const index = this.costumes.findIndex(c => c.name === costume);\n      if (index > -1) {\n        this.costumeNumber = index + 1;\n      } else {\n        switch (costume) {\n          case \"next costume\":\n          case \"next backdrop\": {\n            this.costumeNumber = this.costumeNumber + 1;\n            break;\n          }\n\n          case \"previous costume\":\n          case \"previous backdrop\": {\n            this.costumeNumber = this.costumeNumber - 1;\n            break;\n          }\n\n          case \"random costume\":\n          case \"random backdrop\": {\n            // Based on joker314's inclusiveRandIntWithout: https://github.com/LLK/scratch-vm/pull/2011\n            // Note: We use 1 -> length instead of 0 -> length-1, since we want a 1-indexed result.\n            const lower = 1;\n            const upper = this.costumes.length;\n            const excluded = this.costumeNumber;\n\n            const possibleOptions = upper - lower;\n            let randInt = lower + Math.floor(Math.random() * possibleOptions);\n            if (randInt >= excluded) {\n              randInt++;\n            }\n\n            this.costumeNumber = randInt;\n            break;\n          }\n\n          default: {\n            if (!(isNaN(costume) || costume.trim().length === 0)) {\n              this.costumeNumber = Number(costume);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  get costume() {\n    return this.costumes[this.costumeNumber - 1];\n  }\n\n  moveAhead(value = Infinity) {\n    if (typeof value === \"number\") {\n      this._project.changeSpriteLayer(this, value);\n    } else {\n      this._project.changeSpriteLayer(this, 1, value);\n    }\n  }\n\n  moveBehind(value = Infinity) {\n    if (typeof value === \"number\") {\n      this._project.changeSpriteLayer(this, -value);\n    } else {\n      this._project.changeSpriteLayer(this, -1, value);\n    }\n  }\n\n  degToRad(deg) {\n    return (deg * Math.PI) / 180;\n  }\n\n  radToDeg(rad) {\n    return (rad * 180) / Math.PI;\n  }\n\n  degToScratch(deg) {\n    return -deg + 90;\n  }\n\n  scratchToDeg(scratchDir) {\n    return -scratchDir + 90;\n  }\n\n  radToScratch(rad) {\n    return this.degToScratch(this.radToDeg(rad));\n  }\n\n  scratchToRad(scratchDir) {\n    return this.degToRad(this.scratchToDeg(scratchDir));\n  }\n\n  // Wrap rotation from -180 to 180.\n  normalizeDeg(deg) {\n    // This is a pretty big math expression, but it's necessary because in JavaScript,\n    // the % operator means \"remainder\", not \"modulo\", and so negative numbers won't \"wrap around\".\n    // See https://web.archive.org/web/20090717035140if_/javascript.about.com/od/problemsolving/a/modulobug.htm\n    return ((((deg + 180) % 360) + 360) % 360) - 180;\n  }\n\n  // Given a generator function, return a version of it that runs in \"warp mode\" (no yields).\n  warp(procedure) {\n    const bound = procedure.bind(this);\n    return (...args) => {\n      const inst = bound(...args);\n      while (!inst.next().done);\n    };\n  }\n\n  random(a, b) {\n    const min = Math.min(a, b);\n    const max = Math.max(a, b);\n    if (min % 1 === 0 && max % 1 === 0) {\n      return Math.floor(Math.random() * (max - min + 1)) + min;\n    }\n    return Math.random() * (max - min) + min;\n  }\n\n  *wait(secs) {\n    let endTime = new Date();\n    endTime.setMilliseconds(endTime.getMilliseconds() + secs * 1000);\n    while (new Date() < endTime) {\n      yield;\n    }\n  }\n\n  get mouse() {\n    return this._project.input.mouse;\n  }\n\n  keyPressed(name) {\n    return this._project.input.keyPressed(name);\n  }\n\n  get timer() {\n    const ms = new Date() - this._project.timerStart;\n    return ms / 1000;\n  }\n\n  restartTimer() {\n    this._project.restartTimer();\n  }\n\n  *startSound(soundName) {\n    const sound = this.getSound(soundName);\n    if (sound) {\n      this.effectChain.applyToSound(sound);\n      yield* sound.start();\n    }\n  }\n\n  *playSoundUntilDone(soundName) {\n    const sound = this.getSound(soundName);\n    if (sound) {\n      sound.connect(this.effectChain.inputNode);\n      this.effectChain.applyToSound(sound);\n      yield* sound.playUntilDone();\n    }\n  }\n\n  getSound(soundName) {\n    if (typeof soundName === \"number\") {\n      return this.sounds[(soundName - 1) % this.sounds.length];\n    } else {\n      return this.sounds.find(s => s.name === soundName);\n    }\n  }\n\n  stopAllSounds() {\n    this._project.stopAllSounds();\n  }\n\n  stopAllOfMySounds() {\n    for (const sound of this.sounds) {\n      sound.stop();\n    }\n  }\n\n  broadcast(name) {\n    return this._project.fireTrigger(Trigger.BROADCAST, { name });\n  }\n\n  *broadcastAndWait(name) {\n    let running = true;\n    this.broadcast(name).then(() => {\n      running = false;\n    });\n\n    while (running) {\n      yield;\n    }\n  }\n\n  clearPen() {\n    this._project.renderer.clearPen();\n  }\n\n  *askAndWait(question) {\n    if (this._speechBubble) {\n      this.say(null);\n    }\n\n    let done = false;\n    this._project.askAndWait(question).then(() => {\n      done = true;\n    });\n\n    while (!done) yield;\n  }\n\n  get answer() {\n    return this._project.answer;\n  }\n}\n\nexport class Sprite extends SpriteBase {\n  constructor(initialConditions, ...args) {\n    super(initialConditions, ...args);\n\n    const {\n      x,\n      y,\n      direction,\n      rotationStyle,\n      costumeNumber,\n      size,\n      visible,\n      penDown,\n      penSize,\n      penColor\n    } = initialConditions;\n\n    this._x = x;\n    this._y = y;\n    this._direction = direction;\n    this.rotationStyle = rotationStyle || Sprite.RotationStyle.ALL_AROUND;\n    this._costumeNumber = costumeNumber;\n    this.size = size;\n    this.visible = visible;\n\n    this.parent = null;\n    this.clones = [];\n\n    this._penDown = penDown || false;\n    this.penSize = penSize || 1;\n    this._penColor = penColor || Color.rgb(0, 0, 0);\n\n    this._speechBubble = {\n      text: \"\",\n      style: \"say\",\n      timeout: null\n    };\n  }\n\n  createClone() {\n    const clone = Object.assign(\n      Object.create(Object.getPrototypeOf(this)),\n      this\n    );\n\n    clone._project = this._project;\n    clone.triggers = this.triggers.map(\n      trigger => new Trigger(trigger.trigger, trigger.options, trigger._script)\n    );\n    clone.costumes = this.costumes;\n    clone.sounds = this.sounds;\n    clone._vars = Object.assign({}, this._vars);\n\n    clone._speechBubble = {\n      text: \"\",\n      style: \"say\",\n      timeout: null\n    };\n\n    clone.effects = this.effects._clone();\n\n    // Clones inherit audio effects from the original sprite, for some reason.\n    // Couldn't explain it, but that's the behavior in Scratch 3.0.\n    let original = this;\n    while (original.parent) {\n      original = original.parent;\n    }\n    clone.effectChain = original.effectChain.clone({\n      getNonPatchSoundList: clone.getSoundsPlayedByMe.bind(clone)\n    });\n\n    // Make a new audioEffects interface which acts on the cloned effect chain.\n    clone.audioEffects = new AudioEffectMap(clone.effectChain);\n\n    clone.clones = [];\n    clone.parent = this;\n    this.clones.push(clone);\n\n    // Trigger CLONE_START:\n    const triggers = clone.triggers.filter(tr =>\n      tr.matches(Trigger.CLONE_START)\n    );\n    this._project._startTriggers(\n      triggers.map(trigger => ({ trigger, target: clone }))\n    );\n  }\n\n  deleteThisClone() {\n    if (this.parent === null) return;\n\n    this.parent.clones = this.parent.clones.filter(clone => clone !== this);\n\n    this._project.runningTriggers = this._project.runningTriggers.filter(\n      ({ target }) => target !== this\n    );\n  }\n\n  andClones() {\n    return [this, ...this.clones.flatMap(clone => clone.andClones())];\n  }\n\n  get direction() {\n    return this._direction;\n  }\n\n  set direction(dir) {\n    this._direction = this.normalizeDeg(dir);\n  }\n\n  goto(x, y) {\n    if (x === this.x && y === this.y) return;\n\n    if (this.penDown) {\n      this._project.renderer.penLine(\n        { x: this._x, y: this._y },\n        { x, y },\n        this._penColor,\n        this.penSize\n      );\n    }\n\n    this._x = x;\n    this._y = y;\n  }\n\n  get x() {\n    return this._x;\n  }\n\n  set x(x) {\n    this.goto(x, this._y);\n  }\n\n  get y() {\n    return this._y;\n  }\n\n  set y(y) {\n    this.goto(this._x, y);\n  }\n\n  move(dist) {\n    const moveDir = this.scratchToRad(this.direction);\n\n    this.goto(\n      this._x + dist * Math.cos(moveDir),\n      this._y + dist * Math.sin(moveDir)\n    );\n  }\n\n  *glide(seconds, x, y) {\n    const interpolate = (a, b, t) => a + (b - a) * t;\n\n    const startTime = new Date();\n    const startX = this._x;\n    const startY = this._y;\n\n    let t;\n    do {\n      t = (new Date() - startTime) / (seconds * 1000);\n      this.goto(interpolate(startX, x, t), interpolate(startY, y, t));\n      yield;\n    } while (t < 1);\n  }\n\n  get penDown() {\n    return this._penDown;\n  }\n\n  set penDown(penDown) {\n    if (penDown) {\n      this._project.renderer.penLine(\n        { x: this.x, y: this.y },\n        { x: this.x, y: this.y },\n        this._penColor,\n        this.penSize\n      );\n    }\n    this._penDown = penDown;\n  }\n\n  get penColor() {\n    return this._penColor;\n  }\n\n  set penColor(color) {\n    if (color instanceof Color) {\n      this._penColor = color;\n    } else {\n      console.error(\n        `${color} is not a valid penColor. Try using the Color class!`\n      );\n    }\n  }\n\n  stamp() {\n    this._project.renderer.stamp(this);\n  }\n\n  touching(target, fast = false) {\n    if (typeof target === \"string\") {\n      switch (target) {\n        case \"mouse\":\n          return this._project.renderer.checkPointCollision(\n            this,\n            {\n              x: this.mouse.x,\n              y: this.mouse.y\n            },\n            fast\n          );\n        default:\n          console.error(\n            `Cannot find target \"${target}\" in \"touching\". Did you mean to pass a sprite class instead?`\n          );\n          return false;\n      }\n    } else if (target instanceof Color) {\n      return this._project.renderer.checkColorCollision(this, target);\n    }\n\n    return this._project.renderer.checkSpriteCollision(this, target, fast);\n  }\n\n  colorTouching(color, target) {\n    if (typeof target === \"string\") {\n      console.error(\n        `Cannot find target \"${target}\" in \"touchingColor\". Did you mean to pass a sprite class instead?`\n      );\n      return false;\n    }\n\n    if (typeof color === \"string\") {\n      console.error(\n        `Cannot find color \"${color}\" in \"touchingColor\". Did you mean to pass a Color instance instead?`\n      );\n      return false;\n    }\n\n    if (target instanceof Color) {\n      // \"Color is touching color\"\n      return this._project.renderer.checkColorCollision(this, target, color);\n    } else {\n      // \"Color is touching sprite\" (not implemented in Scratch!)\n      return this._project.renderer.checkSpriteCollision(\n        this,\n        target,\n        false,\n        color\n      );\n    }\n  }\n\n  say(text) {\n    clearTimeout(this._speechBubble.timeout);\n    this._speechBubble = { text: String(text), style: \"say\", timeout: null };\n  }\n\n  think(text) {\n    clearTimeout(this._speechBubble.timeout);\n    this._speechBubble = { text: String(text), style: \"think\", timeout: null };\n  }\n\n  *sayAndWait(text, seconds) {\n    clearTimeout(this._speechBubble.timeout);\n\n    let done = false;\n    const timeout = setTimeout(() => {\n      this._speechBubble.text = \"\";\n      this.timeout = null;\n      done = true;\n    }, seconds * 1000);\n\n    this._speechBubble = { text, style: \"say\", timeout };\n    while (!done) yield;\n  }\n\n  *thinkAndWait(text, seconds) {\n    clearTimeout(this._speechBubble.timeout);\n\n    let done = false;\n    const timeout = setTimeout(() => {\n      this._speechBubble.text = \"\";\n      this.timeout = null;\n      done = true;\n    }, seconds * 1000);\n\n    this._speechBubble = { text, style: \"think\", timeout };\n    while (!done) yield;\n  }\n}\n\nSprite.RotationStyle = Object.freeze({\n  ALL_AROUND: Symbol(\"ALL_AROUND\"),\n  LEFT_RIGHT: Symbol(\"LEFT_RIGHT\"),\n  DONT_ROTATE: Symbol(\"DONT_ROTATE\")\n});\n\nexport class Stage extends SpriteBase {\n  constructor(initialConditions, ...args) {\n    super(initialConditions, ...args);\n\n    // Use defineProperties to make these non-writable.\n    // Changing the width and height of the stage after initialization isn't supported.\n    Object.defineProperties(this, {\n      width: {\n        value: initialConditions.width || 480,\n        enumerable: true\n      },\n      height: {\n        value: initialConditions.height || 360,\n        enumerable: true\n      }\n    });\n\n    this.name = \"Stage\";\n\n    // For obsolete counter blocks.\n    this.__counter = 0;\n  }\n}\n","import Matrix from \"./renderer/Matrix.js\";\nimport PenSkin from \"./renderer/PenSkin.js\";\nimport Rectangle from \"./renderer/Rectangle.js\";\nimport ShaderManager from \"./renderer/ShaderManager.js\";\nimport SkinCache from \"./renderer/SkinCache.js\";\nimport { effectBitmasks } from \"./renderer/effectInfo.js\";\n\nimport { Sprite, Stage } from \"./Sprite.js\";\n\nexport default class Renderer {\n  constructor(project, renderTarget) {\n    const w = project.stage.width;\n    const h = project.stage.height;\n    this.project = project;\n    this.stage = this.createStage(w, h);\n    this.gl = this.stage.getContext(\"webgl\", { antialias: false });\n\n    if (renderTarget) {\n      this.setRenderTarget(renderTarget);\n    } else {\n      this.renderTarget = null;\n    }\n\n    this._shaderManager = new ShaderManager(this);\n    this._skinCache = new SkinCache(this);\n\n    this._currentShader = null;\n    this._currentFramebuffer = null;\n    this._screenSpaceScale = 1;\n\n    // Initialize a bunch of WebGL state\n    const gl = this.gl;\n\n    // Use premultiplied alpha for proper color blending.\n    gl.enable(gl.BLEND);\n    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);\n\n    // Initialize vertex buffer. This will draw one 2D quadrilateral.\n    const buffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n\n    // These are 6 points which make up 2 triangles which make up 1 quad/rectangle.\n    gl.bufferData(\n      gl.ARRAY_BUFFER,\n      // Prettier mangles the formatting here but every 2 array values make one (x, y) pair\n      // and every 6 values make one triangle\n      new Float32Array([0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0]),\n      gl.STATIC_DRAW\n    );\n\n    // Set the active texture unit to 0.\n    gl.activeTexture(gl.TEXTURE0);\n\n    this._penSkin = new PenSkin(this, w, h);\n\n    // This framebuffer is where sprites are drawn for e.g. \"touching\" checks.\n    this._collisionBuffer = this._createFramebufferInfo(\n      w,\n      h,\n      gl.NEAREST,\n      true // stencil\n    );\n  }\n\n  // Create a framebuffer info object, which contains the following:\n  // * The framebuffer itself.\n  // * The texture backing the framebuffer.\n  // * The resolution (width and height) of the framebuffer.\n  _createFramebufferInfo(width, height, filtering, stencil = false) {\n    // Create an empty texture with this skin's dimensions.\n    const gl = this.gl;\n    const texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filtering);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filtering);\n    gl.texImage2D(\n      gl.TEXTURE_2D,\n      0,\n      gl.RGBA,\n      width,\n      height,\n      0,\n      gl.RGBA,\n      gl.UNSIGNED_BYTE,\n      null\n    );\n\n    // Create a framebuffer backed by said texture. This means we can draw onto the framebuffer,\n    // and the results appear in the texture.\n    const framebufferInfo = {\n      texture,\n      width,\n      height,\n      framebuffer: gl.createFramebuffer()\n    };\n    this._setFramebuffer(framebufferInfo);\n    gl.framebufferTexture2D(\n      gl.FRAMEBUFFER,\n      gl.COLOR_ATTACHMENT0,\n      gl.TEXTURE_2D,\n      texture,\n      0\n    );\n\n    // The depth buffer is unnecessary, but WebGL only guarantees\n    // that certain combinations of framebuffer attachments will work, and \"stencil but no depth\" is not among them.\n    if (stencil) {\n      const renderbuffer = gl.createRenderbuffer();\n      gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);\n      gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, width, height);\n      gl.framebufferRenderbuffer(\n        gl.FRAMEBUFFER,\n        gl.DEPTH_STENCIL_ATTACHMENT,\n        gl.RENDERBUFFER,\n        renderbuffer\n      );\n    }\n\n    return framebufferInfo;\n  }\n\n  _setShader(shader) {\n    if (shader !== this._currentShader) {\n      const gl = this.gl;\n      gl.useProgram(shader.program);\n\n      // These attributes and uniforms don't ever change, but must be set whenever a new shader program is used.\n\n      const attribLocation = shader.attrib(\"a_position\");\n      gl.enableVertexAttribArray(attribLocation);\n      // Bind the 'a_position' vertex attribute to the current contents of `gl.ARRAY_BUFFER`, which in this case\n      // is a quadrilateral (as buffered earlier).\n      gl.vertexAttribPointer(\n        attribLocation,\n        2, // every 2 array elements make one vertex.\n        gl.FLOAT, // data type\n        false, // normalized\n        0, // stride (space between attributes)\n        0 // offset (index of the first attribute to start from)\n      );\n\n      this._currentShader = shader;\n      this._updateStageSize();\n\n      return true;\n    }\n\n    return false;\n  }\n\n  _setFramebuffer(framebufferInfo) {\n    if (framebufferInfo !== this._currentFramebuffer) {\n      this._currentFramebuffer = framebufferInfo;\n      if (framebufferInfo === null) {\n        // The \"null\" framebuffer means the drawing buffer which we're displaying to the screen.\n        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);\n        this._updateStageSize();\n      } else {\n        this.gl.bindFramebuffer(\n          this.gl.FRAMEBUFFER,\n          framebufferInfo.framebuffer\n        );\n        // Make sure to update the drawing viewport to the current framebuffer size.\n        this.gl.viewport(0, 0, framebufferInfo.width, framebufferInfo.height);\n      }\n    }\n  }\n\n  setRenderTarget(renderTarget) {\n    if (typeof renderTarget === \"string\") {\n      renderTarget = document.querySelector(renderTarget);\n    }\n    this.renderTarget = renderTarget;\n    this.renderTarget.classList.add(\"leopard__project\");\n    this.renderTarget.style.width = `${this.project.stage.width}px`;\n    this.renderTarget.style.height = `${this.project.stage.height}px`;\n\n    this.renderTarget.append(this.stage);\n  }\n\n  // Handles rendering of all layers (including stage, pen layer, sprites, and all clones) in proper order.\n  _renderLayers(layers, options = {}) {\n    options = Object.assign(\n      {},\n      {\n        drawMode: ShaderManager.DrawModes.DEFAULT,\n        renderSpeechBubbles: true\n      },\n      options\n    );\n\n    // If we're given a list of layers, filter by that.\n    // If we're given a filter function in the options, filter by that too.\n    // If we're given both, then only include layers which match both.\n    const shouldRestrictLayers = layers instanceof Set;\n    const shouldFilterLayers = typeof options.filter === \"function\";\n    const shouldIncludeLayer = layer =>\n      !(\n        (shouldRestrictLayers && !layers.has(layer)) ||\n        (shouldFilterLayers && !options.filter(layer))\n      );\n\n    // Stage\n    if (shouldIncludeLayer(this.project.stage)) {\n      this.renderSprite(this.project.stage, options);\n    }\n\n    // Pen layer\n    if (shouldIncludeLayer(this._penSkin)) {\n      const penMatrix = Matrix.create();\n      Matrix.scale(\n        penMatrix,\n        penMatrix,\n        this._penSkin.width,\n        -this._penSkin.height\n      );\n      Matrix.translate(penMatrix, penMatrix, -0.5, -0.5);\n\n      this._setSkinUniforms(\n        this._penSkin,\n        options.drawMode,\n        penMatrix,\n        1,\n        null\n      );\n      this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);\n    }\n\n    // Sprites + clones\n    for (const sprite of this.project.spritesAndClones) {\n      // Stage doesn't have \"visible\" defined, so check if it's strictly false\n      if (shouldIncludeLayer(sprite) && sprite.visible !== false) {\n        this.renderSprite(sprite, options);\n      }\n    }\n  }\n\n  _updateStageSize() {\n    if (this._currentShader) {\n      // The shader is passed things in \"Scratch-space\" (-240, 240) and (-180, 180).\n      // This tells it those dimensions so it can convert them to OpenGL \"clip-space\" (-1, 1).\n      this.gl.uniform2f(\n        this._currentShader.uniform(\"u_stageSize\"),\n        this.project.stage.width,\n        this.project.stage.height\n      );\n    }\n\n    if (this._currentFramebuffer === null) {\n      this.gl.viewport(\n        0,\n        0,\n        this.gl.drawingBufferWidth,\n        this.gl.drawingBufferHeight\n      );\n    }\n  }\n\n  // Keep the canvas size in sync with the CSS size.\n  _resize() {\n    const stageSize = this.stage.getBoundingClientRect();\n    const ratio = window.devicePixelRatio;\n    const adjustedWidth = Math.round(stageSize.width * ratio);\n    const adjustedHeight = Math.round(stageSize.height * ratio);\n    if (\n      this.stage.width !== adjustedWidth ||\n      this.stage.height !== adjustedHeight\n    ) {\n      this.stage.width = adjustedWidth;\n      this.stage.height = adjustedHeight;\n      this._screenSpaceScale = Math.max(\n        adjustedWidth / this.project.stage.width,\n        adjustedHeight / this.project.stage.height\n      );\n\n      this._updateStageSize();\n    }\n  }\n\n  update() {\n    this._resize();\n\n    // Draw to the screen, not to a framebuffer.\n    this._setFramebuffer(null);\n\n    // Clear to opaque white.\n    const gl = this.gl;\n    gl.clearColor(1, 1, 1, 1);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n    // TODO: find a way to not destroy the skins of hidden sprites\n    this._skinCache.beginTrace();\n    this._renderLayers();\n    this._skinCache.endTrace();\n  }\n\n  createStage(w, h) {\n    const stage = document.createElement(\"canvas\");\n    stage.width = w;\n    stage.height = h;\n\n    // Size canvas to parent container\n    stage.style.width = stage.style.height = \"100%\";\n\n    // If the container width is a non-integer size, don't blur the canvas.\n    // Chrome:\n    stage.style.imageRendering = \"pixelated\";\n    // Firefox:\n    stage.style.imageRendering = \"crisp-edges\";\n    // Safari + Opera:\n    stage.style.imageRendering = \"-webkit-optimize-contrast\";\n\n    return stage;\n  }\n\n  _setSkinUniforms(skin, drawMode, matrix, scale, effects, effectMask) {\n    const gl = this.gl;\n\n    const skinTexture = skin.getTexture(scale * this._screenSpaceScale);\n    if (!skinTexture) return;\n\n    let effectBitmask = 0;\n    if (effects) effectBitmask = effects._bitmask;\n    if (typeof effectMask === \"number\") effectBitmask &= effectMask;\n    const shader = this._shaderManager.getShader(drawMode, effectBitmask);\n    this._setShader(shader);\n    gl.uniformMatrix3fv(shader.uniform(\"u_transform\"), false, matrix);\n\n    if (effectBitmask !== 0) {\n      for (const effect of Object.keys(effects._effectValues)) {\n        const effectVal = effects._effectValues[effect];\n        if (effectVal !== 0)\n          gl.uniform1f(shader.uniform(`u_${effect}`), effectVal);\n      }\n\n      // Pixelate effect needs the skin size\n      if (effects._effectValues.pixelate !== 0)\n        gl.uniform2f(shader.uniform(\"u_skinSize\"), skin.width, skin.height);\n    }\n\n    gl.bindTexture(gl.TEXTURE_2D, skinTexture);\n    // All textures are bound to texture unit 0, so that's where the texture sampler should point\n    gl.uniform1i(shader.uniform(\"u_texture\"), 0);\n  }\n\n  // Calculate the transform matrix for a sprite.\n  // TODO: store the transform matrix in the sprite itself. That adds some complexity though,\n  // so it's better off in another PR.\n  _calculateSpriteMatrix(spr) {\n    // These transforms are actually in reverse order because lol matrices\n    const m = Matrix.create();\n    if (!(spr instanceof Stage)) {\n      Matrix.translate(m, m, spr.x, spr.y);\n      switch (spr.rotationStyle) {\n        case Sprite.RotationStyle.ALL_AROUND: {\n          Matrix.rotate(m, m, spr.scratchToRad(spr.direction));\n          break;\n        }\n        case Sprite.RotationStyle.LEFT_RIGHT: {\n          if (spr.direction < 0) Matrix.scale(m, m, -1, 1);\n          break;\n        }\n      }\n\n      const spriteScale = spr.size / 100;\n      Matrix.scale(m, m, spriteScale, spriteScale);\n    }\n\n    const scalingFactor = 1 / spr.costume.resolution;\n    // Rotation centers are in non-Scratch space (positive y-values = down),\n    // but these transforms are in Scratch space (negative y-values = down).\n    Matrix.translate(\n      m,\n      m,\n      -spr.costume.center.x * scalingFactor,\n      (spr.costume.center.y - spr.costume.height) * scalingFactor\n    );\n    Matrix.scale(\n      m,\n      m,\n      spr.costume.width * scalingFactor,\n      spr.costume.height * scalingFactor\n    );\n\n    return m;\n  }\n\n  // Calculate the transform matrix for a speech bubble attached to a sprite.\n  _calculateSpeechBubbleMatrix(spr, speechBubbleSkin) {\n    const sprBounds = this.getBoundingBox(spr);\n    let x;\n    if (\n      speechBubbleSkin.width + sprBounds.right >\n      this.project.stage.width / 2\n    ) {\n      x = sprBounds.left - speechBubbleSkin.width;\n      speechBubbleSkin.flipped = true;\n    } else {\n      x = sprBounds.right;\n      speechBubbleSkin.flipped = false;\n    }\n    x = Math.round(x - speechBubbleSkin.offsetX);\n    const y = Math.round(sprBounds.top - speechBubbleSkin.offsetY);\n\n    const m = Matrix.create();\n    Matrix.translate(m, m, x, y);\n    Matrix.scale(m, m, speechBubbleSkin.width, speechBubbleSkin.height);\n\n    return m;\n  }\n\n  renderSprite(sprite, options) {\n    const spriteScale = Object.prototype.hasOwnProperty.call(sprite, \"size\")\n      ? sprite.size / 100\n      : 1;\n\n    this._setSkinUniforms(\n      this._skinCache.getSkin(sprite.costume),\n      options.drawMode,\n      this._calculateSpriteMatrix(sprite),\n      spriteScale,\n      sprite.effects,\n      options.effectMask\n    );\n    if (Array.isArray(options.colorMask))\n      this.gl.uniform4fv(\n        this._currentShader.uniform(\"u_colorMask\"),\n        options.colorMask\n      );\n    this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);\n\n    if (\n      options.renderSpeechBubbles &&\n      sprite._speechBubble &&\n      sprite._speechBubble.text !== \"\"\n    ) {\n      const speechBubbleSkin = this._skinCache.getSkin(sprite._speechBubble);\n\n      this._setSkinUniforms(\n        speechBubbleSkin,\n        options.drawMode,\n        this._calculateSpeechBubbleMatrix(sprite, speechBubbleSkin),\n        1,\n        null\n      );\n      this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);\n    }\n  }\n\n  getBoundingBox(sprite) {\n    return Rectangle.fromMatrix(this._calculateSpriteMatrix(sprite));\n  }\n\n  // Mask drawing in to only areas where this sprite is opaque.\n  _stencilSprite(spr, colorMask) {\n    const gl = this.gl;\n    gl.clearColor(0, 0, 0, 0);\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);\n\n    // Enable stenciling. This means that:\n    // 1. Only pixels which pass the \"stencil test\" will be drawn.\n    // 2. Anything rendered will also draw to the stencil buffer.\n    gl.enable(gl.STENCIL_TEST);\n    // Pass the stencil test regardless of what's in the stencil buffer.\n    // Note that pixels which the shader has discarded will still fail the stencil test.\n    // 1 is the reference value which we use in the next line.\n    gl.stencilFunc(gl.ALWAYS, 1, 1);\n    // If the stencil test passes (in this case, if the shader hasn't discarded the pixel),\n    // draw a 1 to that pixel in the stencil buffer, replacing whatever's already there.\n    gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);\n    // Don't draw to the color buffer. Only to the stencil buffer.\n    gl.colorMask(false, false, false, false);\n    // Draw the sprite in the \"silhouette\" mode, which discards transparent pixels.\n    // This, along with the above line, has the effect of not drawing anything to the color buffer, but\n    // creating a \"mask\" in the stencil buffer that masks out all pixels where this sprite is transparent.\n\n    const opts = {\n      drawMode: ShaderManager.DrawModes.SILHOUETTE,\n      renderSpeechBubbles: false,\n      // Ignore ghost effect\n      effectMask: ~effectBitmasks.ghost\n    };\n\n    // If we mask in the color (for e.g. \"color is touching color\"),\n    // we need to pass that in as a uniform as well.\n    if (colorMask) {\n      opts.colorMask = colorMask.toRGBANormalized();\n      opts.drawMode = ShaderManager.DrawModes.COLOR_MASK;\n    }\n    this._renderLayers(new Set([spr]), opts);\n\n    // Pass the stencil test if the stencil buffer value equals 1 (e.g. the pixel got masked in above).\n    gl.stencilFunc(gl.EQUAL, 1, 1);\n    // Keep the current stencil buffer values no matter what.\n    gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);\n    // We can draw to the color buffer again. Note that only pixels which pass the stencil test are drawn.\n    gl.colorMask(true, true, true, true);\n  }\n\n  checkSpriteCollision(spr, targets, fast, sprColor) {\n    if (!spr.visible) return false;\n    if (!(targets instanceof Set)) {\n      if (targets instanceof Array) {\n        targets = new Set(targets);\n      } else {\n        targets = new Set([targets]);\n      }\n    }\n\n    const sprBox = this.getBoundingBox(spr).snapToInt();\n\n    // This is an \"impossible rectangle\"-- its left bound is infinitely far to the right,\n    // its right bound is infinitely to the left, and so on. Its size is effectively -Infinity.\n    // Its only purpose is to be the \"identity rectangle\" that starts the rectangle union process.\n    const targetBox = Rectangle.fromBounds(\n      Infinity,\n      -Infinity,\n      Infinity,\n      -Infinity\n    );\n    for (const target of targets) {\n      Rectangle.union(\n        targetBox,\n        this.getBoundingBox(target).snapToInt(),\n        targetBox\n      );\n    }\n\n    if (!sprBox.intersects(targetBox)) return false;\n    if (fast) return true;\n\n    const cx = this._collisionBuffer.width / 2;\n    const cy = this._collisionBuffer.height / 2;\n    const collisionBox = Rectangle.intersection(sprBox, targetBox).clamp(\n      -cx,\n      cx,\n      -cy,\n      cy\n    );\n\n    if (collisionBox.width === 0 || collisionBox.height === 0) return;\n\n    this._setFramebuffer(this._collisionBuffer);\n    // Enable stencil testing then stencil in this sprite, which masks all further drawing to this sprite's area.\n    this._stencilSprite(spr, sprColor);\n\n    // Render the sprites to check that we're touching, which will now be masked in to the area of the first sprite.\n    this._renderLayers(targets, {\n      drawMode: ShaderManager.DrawModes.SILHOUETTE,\n      // Ignore ghost effect\n      effectMask: ~effectBitmasks.ghost\n    });\n\n    const gl = this.gl;\n    // Make sure to disable the stencil test so as not to affect other rendering!\n    gl.disable(gl.STENCIL_TEST);\n\n    const pixelData = new Uint8Array(\n      collisionBox.width * collisionBox.height * 4\n    );\n    gl.readPixels(\n      collisionBox.left + cx,\n      collisionBox.bottom + cy,\n      collisionBox.width,\n      collisionBox.height,\n      gl.RGBA,\n      gl.UNSIGNED_BYTE,\n      pixelData\n    );\n\n    // Any opaque pixel = an overlap between the two sprites.\n    for (let i = 0; i < pixelData.length; i += 4) {\n      if (pixelData[i + 3] !== 0) return true;\n    }\n\n    return false;\n  }\n\n  checkColorCollision(spr, targetsColor, sprColor) {\n    const sprBox = this.getBoundingBox(spr).snapToInt();\n\n    const cx = this._collisionBuffer.width / 2;\n    const cy = this._collisionBuffer.height / 2;\n    sprBox.clamp(-cx, cx, -cy, cy);\n\n    if (sprBox.width === 0 || sprBox.height === 0) return false;\n\n    this._setFramebuffer(this._collisionBuffer);\n    const gl = this.gl;\n    gl.clearColor(0, 0, 0, 0);\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);\n\n    this._setFramebuffer(this._collisionBuffer);\n    // Enable stencil testing then stencil in this sprite, which masks all further drawing to this sprite's area.\n    this._stencilSprite(spr, sprColor);\n\n    // Render the sprites to check that we're touching, which will now be masked in to the area of the first sprite.\n    this._renderLayers(null, {\n      filter: layer => layer !== spr\n    });\n\n    // Make sure to disable the stencil test so as not to affect other rendering!\n    gl.disable(gl.STENCIL_TEST);\n\n    const pixelData = new Uint8Array(sprBox.width * sprBox.height * 4);\n    gl.readPixels(\n      sprBox.left + cx,\n      sprBox.bottom + cy,\n      sprBox.width,\n      sprBox.height,\n      gl.RGBA,\n      gl.UNSIGNED_BYTE,\n      pixelData\n    );\n\n    const color = targetsColor.toRGBA();\n    for (let i = 0; i < pixelData.length; i += 4) {\n      if (\n        // Ensure we're not testing transparent pixels\n        pixelData[i + 3] !== 0 &&\n        // Scratch tests the top 5 bits of the red and green channels,\n        // and the top 4 bits of the blue channel.\n        ((pixelData[i] ^ color[0]) & 0b11111000) === 0 &&\n        ((pixelData[i + 1] ^ color[1]) & 0b11111000) === 0 &&\n        ((pixelData[i + 2] ^ color[2]) & 0b11110000) === 0\n      )\n        return true;\n    }\n\n    return false;\n  }\n\n  checkPointCollision(spr, point, fast) {\n    if (!spr.visible) return false;\n\n    const box = this.getBoundingBox(spr);\n    if (!box.containsPoint(point.x, point.y)) return false;\n    if (fast) return true;\n\n    // TODO: would it be faster to enable a scissor rectangle?\n    this._setFramebuffer(this._collisionBuffer);\n    const gl = this.gl;\n    gl.clearColor(0, 0, 0, 0);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n    this._renderLayers(new Set([spr]), { effectMask: ~effectBitmasks.ghost });\n\n    const hoveredPixel = new Uint8Array(4);\n    const cx = this._collisionBuffer.width / 2;\n    const cy = this._collisionBuffer.height / 2;\n    gl.readPixels(\n      point.x + cx,\n      point.y + cy,\n      1,\n      1,\n      gl.RGBA,\n      gl.UNSIGNED_BYTE,\n      hoveredPixel\n    );\n    return hoveredPixel[3] !== 0;\n  }\n\n  penLine(pt1, pt2, color, size) {\n    this._penSkin.penLine(pt1, pt2, color, size);\n  }\n\n  clearPen() {\n    this._penSkin.clear();\n  }\n\n  stamp(spr) {\n    this._setFramebuffer(this._penSkin._framebufferInfo);\n    this._renderLayers(new Set([spr]), { renderSpeechBubbles: false });\n  }\n\n  displayAskBox(question) {\n    const askBox = document.createElement(\"form\");\n    askBox.classList.add(\"leopard__askBox\");\n\n    const askText = document.createElement(\"span\");\n    askText.classList.add(\"leopard__askText\");\n    askText.innerText = question;\n    askBox.append(askText);\n\n    const askInput = document.createElement(\"input\");\n    askInput.type = \"text\";\n    askInput.classList.add(\"leopard__askInput\");\n    askBox.append(askInput);\n\n    const askButton = document.createElement(\"button\");\n    askButton.classList.add(\"leopard__askButton\");\n    askButton.innerText = \"Answer\";\n    askBox.append(askButton);\n\n    this.renderTarget.append(askBox);\n    askInput.focus();\n\n    return new Promise(resolve => {\n      askBox.addEventListener(\"submit\", e => {\n        e.preventDefault();\n        askBox.remove();\n        resolve(askInput.value);\n      });\n    });\n  }\n}\n","export default class Input {\n  constructor(stage, canvas, onKeyDown) {\n    this._stage = stage;\n    this._canvas = canvas;\n\n    // Allow setting focus to canvas\n    if (this._canvas.tabIndex < 0) {\n      this._canvas.tabIndex = 0;\n    }\n\n    this.mouse = { x: 0, y: 0, down: false };\n    this._canvas.addEventListener(\"mousemove\", this._mouseMove.bind(this));\n    this._canvas.addEventListener(\"mousedown\", this._mouseDown.bind(this));\n    this._canvas.addEventListener(\"mouseup\", this._mouseUp.bind(this));\n\n    this._canvas.addEventListener(\"keyup\", this._keyup.bind(this));\n    this._canvas.addEventListener(\"keydown\", this._keydown.bind(this));\n\n    this.keys = [];\n    this._onKeyDown = onKeyDown;\n  }\n\n  _mouseMove(e) {\n    const rect = this._canvas.getBoundingClientRect();\n    const scaleX = this._stage.width / rect.width;\n    const scaleY = this._stage.height / rect.height;\n    const realCoords = {\n      x: (e.clientX - rect.left) * scaleX,\n      y: (e.clientY - rect.top) * scaleY\n    };\n\n    this.mouse = {\n      ...this.mouse,\n      x: realCoords.x - this._stage.width / 2,\n      y: -realCoords.y + this._stage.height / 2\n    };\n  }\n\n  _mouseDown() {\n    this.mouse = {\n      ...this.mouse,\n      down: true\n    };\n  }\n\n  _mouseUp() {\n    this.mouse = {\n      ...this.mouse,\n      down: false\n    };\n  }\n\n  _keyup(e) {\n    const key = this._getKeyName(e);\n    this.keys = this.keys.filter(k => k !== key);\n  }\n\n  _keydown(e) {\n    e.preventDefault();\n\n    const key = this._getKeyName(e);\n    if (this.keys.indexOf(key) === -1) {\n      this.keys.push(key);\n    }\n\n    this._onKeyDown(key);\n  }\n\n  _getKeyName(e) {\n    if (e.key === \"ArrowUp\") return \"up arrow\";\n    if (e.key === \"ArrowDown\") return \"down arrow\";\n    if (e.key === \"ArrowLeft\") return \"left arrow\";\n    if (e.key === \"ArrowRight\") return \"right arrow\";\n    if (e.key === \" \") return \"space\";\n    if (e.code.substring(0, 5) === \"Digit\") return e.code[5];\n\n    return e.key.toLowerCase();\n  }\n\n  keyPressed(name) {\n    if (name === \"any\") return this.keys.length > 0;\n    return this.keys.indexOf(name) > -1;\n  }\n\n  focus() {\n    this._canvas.focus();\n  }\n}\n","import Trigger from \"./Trigger.js\";\nimport Renderer from \"./Renderer.js\";\nimport Input from \"./Input.js\";\nimport { Stage } from \"./Sprite.js\";\n\nexport default class Project {\n  constructor(stage, sprites = {}, { frameRate = 30 } = {}) {\n    this.stage = stage;\n    this.sprites = sprites;\n\n    Object.freeze(sprites); // Prevent adding/removing sprites while project is running\n\n    for (const sprite of this.spritesAndClones) {\n      sprite._project = this;\n    }\n    this.stage._project = this;\n\n    this.renderer = new Renderer(this);\n    this.input = new Input(this.stage, this.renderer.stage, key => {\n      this.fireTrigger(Trigger.KEY_PRESSED, { key });\n    });\n\n    this.runningTriggers = [];\n\n    this.restartTimer();\n\n    this.answer = null;\n\n    // Run project code at specified framerate\n    setInterval(() => {\n      this.step();\n    }, 1000 / frameRate);\n\n    // Render project as fast as possible\n    this._renderLoop();\n  }\n\n  attach(renderTarget) {\n    this.renderer.setRenderTarget(renderTarget);\n    this.renderer.stage.addEventListener(\"click\", () => {\n      const wasClicked = sprite => {\n        if (sprite instanceof Stage) {\n          return true;\n        }\n\n        return this.renderer.checkPointCollision(\n          sprite,\n          {\n            x: this.input.mouse.x,\n            y: this.input.mouse.y\n          },\n          false\n        );\n      };\n\n      let matchingTriggers = [];\n      for (let i = 0; i < this.spritesAndStage.length; i++) {\n        const sprite = this.spritesAndStage[i];\n        const spriteClickedTriggers = sprite.triggers.filter(tr =>\n          tr.matches(Trigger.CLICKED, {})\n        );\n        if (spriteClickedTriggers.length > 0) {\n          if (wasClicked(sprite)) {\n            matchingTriggers = [\n              ...matchingTriggers,\n              ...spriteClickedTriggers.map(trigger => ({\n                trigger,\n                target: sprite\n              }))\n            ];\n          }\n        }\n      }\n\n      this._startTriggers(matchingTriggers);\n    });\n  }\n\n  greenFlag() {\n    this.fireTrigger(Trigger.GREEN_FLAG);\n    this.input.focus();\n  }\n\n  step() {\n    // Step all triggers\n    const alreadyRunningTriggers = this.runningTriggers;\n    for (let i = 0; i < alreadyRunningTriggers.length; i++) {\n      alreadyRunningTriggers[i].trigger.step();\n    }\n\n    // Remove finished triggers\n    this.runningTriggers = this.runningTriggers.filter(\n      ({ trigger }) => !trigger.done\n    );\n  }\n\n  render() {\n    // Render to canvas\n    this.renderer.update(this.stage, this.spritesAndClones);\n\n    // Update watchers\n    for (const sprite of [...Object.values(this.sprites), this.stage]) {\n      for (const watcher of Object.values(sprite.watchers)) {\n        watcher.updateDOM(this.renderer.renderTarget);\n      }\n    }\n  }\n\n  _renderLoop() {\n    requestAnimationFrame(this._renderLoop.bind(this));\n    this.render();\n  }\n\n  fireTrigger(trigger, options) {\n    // Special trigger behaviors\n    if (trigger === Trigger.GREEN_FLAG) {\n      this.restartTimer();\n      this.stopAllSounds();\n      this.runningTriggers = [];\n\n      for (const spriteName in this.sprites) {\n        const sprite = this.sprites[spriteName];\n        sprite.clones = [];\n      }\n\n      for (const sprite of this.spritesAndStage) {\n        sprite.effects.clear();\n        sprite.audioEffects.clear();\n      }\n    }\n\n    // Find triggers which match conditions\n    let matchingTriggers = [];\n    for (let i = 0; i < this.spritesAndStage.length; i++) {\n      const sprite = this.spritesAndStage[i];\n      const spriteTriggers = sprite.triggers.filter(tr =>\n        tr.matches(trigger, options)\n      );\n\n      matchingTriggers = [\n        ...matchingTriggers,\n        ...spriteTriggers.map(trigger => ({ trigger, target: sprite }))\n      ];\n    }\n\n    return this._startTriggers(matchingTriggers);\n  }\n\n  _startTriggers(triggers) {\n    // Only add these triggers to this.runningTriggers if they're not already there.\n    // TODO: if the triggers are already running, they'll be restarted but their execution order is unchanged.\n    // Does that match Scratch's behavior?\n    for (const trigger of triggers) {\n      if (\n        !this.runningTriggers.find(\n          runningTrigger =>\n            trigger.trigger === runningTrigger.trigger &&\n            trigger.target === runningTrigger.target\n        )\n      ) {\n        this.runningTriggers.push(trigger);\n      }\n    }\n    return Promise.all(\n      triggers.map(({ trigger, target }) => {\n        return trigger.start(target);\n      })\n    );\n  }\n\n  get spritesAndClones() {\n    return Object.values(this.sprites)\n      .flatMap(sprite => sprite.andClones())\n      .sort((a, b) => a._layerOrder - b._layerOrder);\n  }\n\n  get spritesAndStage() {\n    return [...this.spritesAndClones, this.stage];\n  }\n\n  changeSpriteLayer(sprite, layerDelta, relativeToSprite = sprite) {\n    let spritesArray = this.spritesAndClones;\n\n    const originalIndex = spritesArray.indexOf(sprite);\n    const relativeToIndex = spritesArray.indexOf(relativeToSprite);\n\n    let newIndex = relativeToIndex + layerDelta;\n    if (newIndex < 0) newIndex = 0;\n    if (newIndex > spritesArray.length - 1) newIndex = spritesArray.length - 1;\n\n    // Remove sprite from originalIndex and insert at newIndex\n    spritesArray.splice(originalIndex, 1);\n    spritesArray.splice(newIndex, 0, sprite);\n\n    // spritesArray is sorted correctly, but to influence\n    // the actual order of the sprites we need to update\n    // each one's _layerOrder property.\n    spritesArray.forEach((sprite, index) => {\n      sprite._layerOrder = index + 1;\n    });\n  }\n\n  stopAllSounds() {\n    for (const target of this.spritesAndStage) {\n      target.stopAllOfMySounds();\n    }\n  }\n\n  restartTimer() {\n    this.timerStart = new Date();\n  }\n\n  async askAndWait(question) {\n    this.answer = await this.renderer.displayAskBox(question);\n  }\n}\n","import Color from \"./Color\";\n\nexport default class Watcher {\n  constructor({\n    value = () => \"\",\n    setValue = () => {},\n    label,\n    style = \"normal\",\n    visible = true,\n    color = Color.rgb(255, 140, 26),\n    step = 1,\n    x = -240,\n    y = 180,\n    width,\n    height\n  }) {\n    this.initializeDOM();\n\n    this.value = value;\n    this.setValue = setValue;\n    this._previousValue = Symbol(\"NO_PREVIOUS_VALUE\");\n\n    this.label = label;\n    this.style = style;\n    this.visible = visible;\n    this.color = color;\n    this.step = step;\n\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n  }\n\n  initializeDOM() {\n    const node = document.createElement(\"div\");\n    node.classList.add(\"leopard__watcher\");\n\n    const label = document.createElement(\"div\");\n    label.classList.add(\"leopard__watcherLabel\");\n    node.append(label);\n\n    const value = document.createElement(\"div\");\n    value.classList.add(\"leopard__watcherValue\");\n    node.append(value);\n\n    const slider = document.createElement(\"input\");\n    slider.type = \"range\";\n    slider.classList.add(\"leopard__watcherSlider\");\n\n    slider.addEventListener(\"input\", event => {\n      this.setValue(Number(event.target.value));\n    });\n\n    node.append(slider);\n\n    this._dom = { node, label, value, slider };\n  }\n\n  updateDOM(renderTarget) {\n    if (renderTarget && !renderTarget.contains(this._dom.node)) {\n      renderTarget.append(this._dom.node);\n    }\n\n    if (!this.visible) return;\n\n    const value = this.value();\n\n    const isList = Array.isArray(value);\n    this._dom.node.classList.toggle(\"leopard__watcher--list\", isList);\n    if (isList) {\n      // Render like a list\n      if (\n        !Array.isArray(this._previousValue) ||\n        JSON.stringify(value.map(String)) !==\n          JSON.stringify(this._previousValue.map(String))\n      ) {\n        this._dom.value.innerHTML = \"\";\n        for (const [index, item] of value.entries()) {\n          const itemElem = document.createElement(\"div\");\n          itemElem.classList.add(\"leopard__watcherListItem\");\n\n          const indexElem = document.createElement(\"div\");\n          indexElem.classList.add(\"leopard__watcherListItemIndex\");\n          indexElem.innerText = index;\n\n          const contentElem = document.createElement(\"div\");\n          contentElem.classList.add(\"leopard__watcherListItemContent\");\n          contentElem.innerText = item.toString();\n\n          itemElem.append(indexElem);\n          itemElem.append(contentElem);\n          this._dom.value.append(itemElem);\n        }\n      }\n    } else {\n      // Render like a normal variable\n      if (value !== this._previousValue) {\n        this._dom.value.innerText = value.toString();\n      }\n    }\n\n    if (isList) {\n      this._previousValue = [...value];\n    } else {\n      this._previousValue = value;\n    }\n\n    // Set slider value\n    if (this._style === \"slider\") {\n      this._dom.slider.value = value;\n    }\n\n    // Update color\n    // (Needs to happen here rather than a setter because\n    // mutation of color object is possible.)\n    const textColor =\n      this.color.r * 0.299 + this.color.g * 0.587 + this.color.b * 0.114 > 162\n        ? \"#000\"\n        : \"#fff\";\n    this._dom.value.style.setProperty(\"--watcher-color\", this.color.toString());\n    this._dom.value.style.setProperty(\"--watcher-text-color\", textColor);\n  }\n\n  get visible() {\n    return this._visible;\n  }\n  set visible(visible) {\n    this._visible = visible;\n    this._dom.node.style.visibility = visible ? \"visible\" : \"hidden\";\n  }\n\n  get x() {\n    return this._x;\n  }\n  set x(x) {\n    this._x = x;\n    this._dom.node.style.left = `${x - 240}px`;\n  }\n\n  get y() {\n    return this._y;\n  }\n  set y(y) {\n    this._y = y;\n    this._dom.node.style.top = `${180 - y}px`;\n  }\n\n  get width() {\n    return this._width;\n  }\n  set width(width) {\n    this._width = width;\n    if (width) {\n      this._dom.node.style.width = `${width}px`;\n    } else {\n      this._dom.node.style.width = undefined;\n    }\n  }\n\n  get height() {\n    return this._height;\n  }\n  set height(height) {\n    this._height = height;\n    if (height) {\n      this._dom.node.style.height = `${height}px`;\n    } else {\n      this._dom.node.style.height = undefined;\n    }\n  }\n\n  get style() {\n    return this._style;\n  }\n  set style(style) {\n    this._style = style;\n    this._dom.node.classList.toggle(\n      \"leopard__watcher--normal\",\n      style === \"normal\"\n    );\n    this._dom.node.classList.toggle(\n      \"leopard__watcher--large\",\n      style === \"large\"\n    );\n    this._dom.node.classList.toggle(\n      \"leopard__watcher--slider\",\n      style === \"slider\"\n    );\n  }\n\n  get min() {\n    return this._min;\n  }\n  set min(min) {\n    this._min = min;\n    this._dom.slider.min = min;\n  }\n\n  get max() {\n    return this._max;\n  }\n  set max(max) {\n    this._max = max;\n    this._dom.slider.max = max;\n  }\n\n  get step() {\n    return this._step;\n  }\n  set step(step) {\n    this._step = step;\n    this._dom.slider.step = step;\n  }\n\n  get label() {\n    return this._label;\n  }\n  set label(label) {\n    this._label = label;\n    this._dom.label.innerText = label;\n  }\n}\n"],"names":["GREEN_FLAG","Symbol","KEY_PRESSED","BROADCAST","CLICKED","CLONE_START","Trigger","[object Object]","trigger","options","script","this","_script","done","stop","option","target","boundScript","bind","_runningScript","Promise","resolve","next","Matrix","matrix","Float32Array","dst","src","x","y","a00","a01","a02","a10","a11","a12","a20","a21","a22","rad","s","Math","sin","c","cos","Skin","renderer","gl","used","scale","image","filtering","glTexture","createTexture","bindTexture","TEXTURE_2D","texParameteri","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","TEXTURE_MIN_FILTER","TEXTURE_MAG_FILTER","texImage2D","RGBA","UNSIGNED_BYTE","complete","width","naturalWidth","height","naturalHeight","addEventListener","SpriteShader","vertex","fragment","PenLineShader","effectNames","effectBitmasks","i","length","Shader","program","_uniformLocations","Map","_attribLocations","numActiveUniforms","getProgramParameter","ACTIVE_UNIFORMS","uniformInfo","getActiveUniform","set","name","getUniformLocation","numActiveAttributes","ACTIVE_ATTRIBUTES","attribInfo","getActiveAttrib","getAttribLocation","attribName","get","uniformName","ShaderManager","_shaderCache","drawMode","Object","keys","DrawModes","source","type","shader","createShader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","getShaderInfoLog","effectBitmask","shaderMap","has","shaderCode","DEFAULT","SILHOUETTE","COLOR_MASK","PEN_LINE","define","effectName","vertShader","_createShader","VERTEX_SHADER","fragShader","FRAGMENT_SHADER","createProgram","attachShader","linkProgram","LINK_STATUS","info","getProgramInfoLog","Error","PenSkin","super","framebufferInfo","_createFramebufferInfo","NEAREST","_framebufferInfo","_lastPenState","size","color","clear","deleteTexture","texture","deleteFramebuffer","framebuffer","pt1","pt2","_setFramebuffer","_shaderManager","getShader","shaderChanged","_setShader","uniform2f","uniform","penColor","toRGBANormalized","oldColor","uniform4fv","uniform1f","uniform4f","drawArrays","TRIANGLES","clearColor","COLOR_BUFFER_BIT","Rectangle","left","Infinity","right","bottom","top","result","xa","xb","absx","abs","sumx","ya","yb","absy","sumy","floor","ceil","rect","min","max","rect1","rect2","BitmapSkin","_image","_texture","_setSizeFromImage","_makeTexture","bubbleStyle","SpeechBubbleSkin","bubble","_canvas","document","createElement","LINEAR","_bubble","_flipped","_rendered","_renderedScale","offsetX","offsetY","_renderBubble","ctx","getContext","font","textBaseline","flipped","canvas","_restyleCanvas","text","style","textWidth","measureText","maxWidth","padding","setTransform","fillStyle","strokeStyle","lineWidth","save","translate","w","h","r","beginPath","moveTo","arcTo","lineTo","ellipse","PI","closePath","stroke","fill","renderBubbleBackground","restore","fillText","VectorSkin","_maxTextureSize","getParameter","MAX_TEXTURE_SIZE","_mipmaps","mipLevel","round","drawImage","log2","_createMipmap","mip","values","Costume","url","center","img","Image","crossOrigin","isBitmap","match","resolution","SkinCache","_renderer","_skins","forEach","skin","key","destroy","delete","obj","clamp","n","rgbToHSV","g","b","delta","v","hsvToRGB","Color","a","Number","rgb","_setRGB","_a","_h","_s","_v","forceIncludeAlpha","toHexDigits","str","toString","hex","map","join","toRGBString","ADPCM_STEPS","ADPCM_INDEX","decodeADPCMAudio","ab","audioContext","dv","DataView","getUint32","reject","blocks","l","byteLength","String","fromCharCode","getUint8","format","getUint16","sampleRate","blockSize","frameCount","fact","buffer","createBuffer","channel","getChannelData","sample","step","code","index","lastByte","offset","data","j","getInt16","isADPCMData","arrayBuffer","dataView","isWavData","Sound","audioBuffer","playbackRate","downloadMyAudioBuffer","duration","started","isLatestCallToStart","_markDone","playMyAudioBuffer","oldDoneDownloading","_doneDownloading","fromMoreRecentCall","playing","start","disconnect","fetch","then","body","catch","error","console","warn","decodeAudioData","createBufferSource","value","connect","currentTime","_setupAudioContext","_audioContext","AudioContext","window","webkitAudioContext","EffectChain","config","getNonPatchSoundList","inputNode","createGain","effectNodes","resetToInitial","initials","getInitialEffectValues","effectValues","initialValue","entries","getEffectDescriptor","reset","setEffectValue","descriptor","isPatch","getNextEffectDescriptor","previous","getPreviousEffectDescriptor","output","input","nodes","initial","makeNodes","node","Set","sound","last","getLastEffectDescriptor","isNaN","clampEffectValue","updateAudioEffect","minimum","maximum","newConfig","newEffectChain","assign","resetOnClone","isConnectedTo","effectDescriptors","find","slice","_","decayDuration","decayWait","aCtx","leftGain","rightGain","channelMerger","createChannelMerger","p","leftVal","rightVal","gain","setTargetAtTime","interval","ratio","pow","setPlaybackRate","resetOnStart","linearRampToValueAtTime","AudioEffectMap","effectChain","defineProperty","getEffectValue","_EffectMap","_bitmask","_effectValues","val","m","SpriteBase","initialConditions","vars","_project","costumeNumber","layerOrder","_costumeNumber","_layerOrder","triggers","watchers","costumes","sounds","getSoundsPlayedByMe","destination","effects","audioEffects","_vars","filter","isTargetOf","stage","sprites","number","costume","findIndex","lower","upper","excluded","possibleOptions","randInt","random","trim","changeSpriteLayer","deg","scratchDir","degToScratch","radToDeg","degToRad","scratchToDeg","procedure","bound","args","inst","secs","endTime","Date","setMilliseconds","getMilliseconds","mouse","keyPressed","timer","timerStart","restartTimer","soundName","getSound","applyToSound","playUntilDone","stopAllSounds","fireTrigger","running","broadcast","clearPen","question","_speechBubble","say","askAndWait","answer","Sprite","direction","rotationStyle","visible","penDown","penSize","_x","_y","_direction","RotationStyle","ALL_AROUND","parent","clones","_penDown","_penColor","timeout","clone","create","getPrototypeOf","_clone","original","push","tr","matches","_startTriggers","runningTriggers","flatMap","andClones","dir","normalizeDeg","penLine","goto","dist","moveDir","scratchToRad","seconds","interpolate","t","startTime","startX","startY","stamp","fast","checkPointCollision","checkColorCollision","checkSpriteCollision","clearTimeout","setTimeout","freeze","LEFT_RIGHT","DONT_ROTATE","Stage","defineProperties","enumerable","__counter","Renderer","project","renderTarget","createStage","antialias","setRenderTarget","_skinCache","_currentShader","_currentFramebuffer","_screenSpaceScale","enable","BLEND","blendFunc","ONE","ONE_MINUS_SRC_ALPHA","pixelStorei","UNPACK_PREMULTIPLY_ALPHA_WEBGL","bindBuffer","ARRAY_BUFFER","bufferData","STATIC_DRAW","activeTexture","TEXTURE0","_penSkin","_collisionBuffer","stencil","createFramebuffer","framebufferTexture2D","FRAMEBUFFER","COLOR_ATTACHMENT0","renderbuffer","createRenderbuffer","bindRenderbuffer","RENDERBUFFER","renderbufferStorage","DEPTH_STENCIL","framebufferRenderbuffer","DEPTH_STENCIL_ATTACHMENT","useProgram","attribLocation","attrib","enableVertexAttribArray","vertexAttribPointer","FLOAT","_updateStageSize","bindFramebuffer","viewport","querySelector","classList","add","append","layers","renderSpeechBubbles","shouldRestrictLayers","shouldFilterLayers","shouldIncludeLayer","layer","renderSprite","penMatrix","_setSkinUniforms","sprite","spritesAndClones","drawingBufferWidth","drawingBufferHeight","stageSize","getBoundingClientRect","devicePixelRatio","adjustedWidth","adjustedHeight","_resize","beginTrace","_renderLayers","endTrace","imageRendering","effectMask","skinTexture","getTexture","uniformMatrix3fv","effect","effectVal","pixelate","uniform1i","spr","rotate","spriteScale","scalingFactor","speechBubbleSkin","sprBounds","getBoundingBox","prototype","hasOwnProperty","call","getSkin","_calculateSpriteMatrix","Array","isArray","colorMask","_calculateSpeechBubbleMatrix","fromMatrix","STENCIL_BUFFER_BIT","STENCIL_TEST","stencilFunc","ALWAYS","stencilOp","KEEP","REPLACE","opts","ghost","EQUAL","targets","sprColor","sprBox","snapToInt","targetBox","fromBounds","union","intersects","cx","cy","collisionBox","intersection","_stencilSprite","disable","pixelData","Uint8Array","readPixels","targetsColor","toRGBA","point","containsPoint","hoveredPixel","askBox","askText","innerText","askInput","askButton","focus","e","preventDefault","remove","Input","onKeyDown","_stage","tabIndex","down","_mouseMove","_mouseDown","_mouseUp","_keyup","_keydown","_onKeyDown","scaleX","scaleY","realCoords","clientX","clientY","_getKeyName","k","indexOf","substring","toLowerCase","Project","frameRate","setInterval","_renderLoop","wasClicked","matchingTriggers","spritesAndStage","spriteClickedTriggers","alreadyRunningTriggers","update","watcher","updateDOM","requestAnimationFrame","render","spriteName","spriteTriggers","runningTrigger","all","sort","layerDelta","relativeToSprite","spritesArray","originalIndex","newIndex","splice","stopAllOfMySounds","displayAskBox","Watcher","setValue","label","initializeDOM","_previousValue","slider","event","_dom","contains","isList","toggle","JSON","stringify","innerHTML","item","itemElem","indexElem","contentElem","_style","textColor","setProperty","_visible","visibility","_width","undefined","_height","_min","_max","_step","_label"],"mappings":"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"}